--- 
:name: Object
:comment: |-
  Object es la clase superior en jerarquía de Ruby. Sus métodos 
  están disponibles para el resto de las clases a menos que se 
  sobreescriba explícitamente.

  Los objetos mezclados en el modulo Kernel, hacen que las funciónes
  incorporadas sean accesibles globalmente. Aunque los métodos de 
  instancia de Object son definidos por el módulo Kernel, hemos elegido
  documentarlos aquí al fin de clarificar.

  En la descripción de métodos para Object, el parámetro <i>symbol</i>
  hace referencia a symbol, el cuál es texto encomillado o un Symbol (
  como <code>:name</code>).

:instance_methods: 
- :name: to_enum
  :arglist: |-
    obj.to_enum(method = :each, *args)
    obj.enum_for(method = :each, *args)
  :comment: |-
    Crea un nuevo Enumerator el cual enumera llamando +method+ sobre
    +obj+.

    +method+:: el método a llamar sobre el +obj+ para generar la enumeración
    +args+:: argumentos que serán pasados en +method+ <i>en adicción</i> al 
             item en si mismo. Observar que el número de argumentos no debe
             exceder de el número esperado por +method+

    === Ejemplo
    
      str = "xyz"
    
      enum = str.enum_for(:each_byte)
      enum.each { |b| puts b }
      # => 120
      # => 121
      # => 122
    
      # proteje un arreglo de ser modificado por some_method
      a = [1, 2, 3]
      some_method(a.to_enum)
- :name: enum_for
  :arglist: |-
    obj.to_enum(method = :each, *args)
    obj.enum_for(method = :each, *args)
  :comment: |-
    Crea un nuevo Enumerator el cuál enumerará llamando +method+ desde +obj+.
    
    +method+:: el método a llamar sobre +obj+ para generar la enumeración
    +args+:: argumentos que serán pasados en +method+ <i>en suma</i>
             al item en si mismo.  Notar que el número de argumentos no debe
             exceder el número esperado por +method+
    
    === Ejemplo
    
      str = "xyz"
    
      enum = str.enum_for(:each_byte)
      enum.each { |b| puts b }
      # => 120
      # => 121
      # => 122
    
      # proteje un array de ser modificado por some_method
      a = [1, 2, 3]
      some_method(a.to_enum)
- :name: extend
  :arglist: obj.extend(module, ...)    -> obj
  :comment: |-
    Agrega a _obj_ los métodos de instancia para cada modulo dado
    como un parametro
    
       module Mod
         def hello
           "Hola desde Mod.\n"
         end
       end
    
       class Klass
         def hello
           "Hola desde Klass.\n"
         end
       end
    
       k = Klass.new
       k.hello         #=> "Hola desde Klass.\n"
       k.extend(Mod)   #=> #<Klass:0x401b3bc8>
       k.hello         #=> "Hola desde Mod.\n"
- :name: object_id
  :arglist: |-
    obj.__id__       -> fixnum
    obj.object_id    -> fixnum
  :comment: |-
    Retorna un valor entero identificador para <i>obj</i>. El mismo número
    se retorna en la llamadas a <code>id</code> para un objeto dado, y dos
    objetods activos no compartiran un id.
    <code>Object#object_id</code> es un concepoto diferente de la notación
    <code>:name</code> la cual retorna el símbolo id de <code>name</code>.
    Reemplaza el deprecado <code>Object#id</code>.

- :name: display
  :arglist: obj.display(port=$>)    -> nil
  :comment: |-
    Imprime <i>obj</i> en el puerto dado (default <code>$></code>).
    Equivalente a:

       def display(port=$>)
         port.write self
       end

    Por ejemplo:
    
       1.display
       "cat".display
       [ 4, 5, 6 ].display
       puts
    
    <em>produce:</em>
    
       1cat456
- :name: nil?
  :arglist: nil?()
  :comment: |-
    call_seq:
      nil.nil?               -> true
      <anything_else>.nil?   -> false
    
    Unicamente el objeto <i>nil</i> responde con <code>true</code> a 
    <code>nil?</code>.
- :name: ===
  :arglist: obj === other   -> true or false
  :comment: |-
    Case Equality---Para clase <code>Object</code>, efectivamente lo mismo
    que llamar <code>#==</code>, pero típicamente sobrescrito por otras 
    clases descendientes para proveer semántica útil en sentencias 
    <code>case</code>.
- :name: =~
  :arglist: obj =~ other  -> nil
  :comment: |-
    Pattern Match---Sobreescrito por clases descendientes (notoriamente
    <code>Regexp</code> y <code>String</code>) para proveer significado a la
    semántica de pattern-match.
- :name: "!~"
  :arglist: obj !~ other  -> true o false
  :comment: |-
    Retorna true si dos objetos no coinciden( usando el método <i>=~</i>), en 
    caso contrario devolverá false
- :name: eql?
  :arglist: |-
    obj == other        -> true o false
    obj.equal?(other)   -> true o false
    obj.eql?(other)     -> true o false
  :comment: |-
    Equality---A nivel de <code>Object</code>, <code>==</code> retorna
    <code>true</code> solamente si <i>obj</i> y <i>other</i> son el
    mismo objeto. Tipicamente, éste objeto sobreescrito por una clase 
    descendiente para proveer significado más especifico dentro de la clase.
    
    Al contrario de <code>==</code>, el método <code>equal?</code> núnca
    deberá ser sobreescrito por una subclase: éste es usado para determinar 
    la identidad del objeto (esto es, <code>a.equal?(b)</code> si <code>a</code> 
    es el mismo objeto como <code>b</code>).
    
    El método <code>eql?</code> retorna <code>true</code> si
    <i>obj</i> y <i>anObject</i> tienen el mismo valor. Es utilizado por
    <code>Hash</code> para testear igualdad.  Para objetos de clase
    <code>Object</code>, <code>eql?</code> es sinónimo con <code>==</code>. 
    Subclases normalmente continunan esta tradición, pero hay excepciónes. 
    Tipos <code>Numeric</code>, por ejemplo, realizan la conversión a travez 
    de <code>==</code>, pero no con <code>eql?</code>, entonces:
    
       1 == 1.0     #=> true
       1.eql? 1.0   #=> false
- :name: hash
  :arglist: hash()
  :comment: |-
    Genera un valor hash <code>Fixnum</code> para el objeto.
    Esta funcion debe tener la propiedad que a.eql?(b) implica
    a.hash <code>==</code> b.hash.
    El valor hash es usado por la clase <code>Hash</code>.
    Cualquier valor hash que excede la capacidad de un <code>Fixnum</code> será
    truncado antes de ser utilizado.
    
         "waffle".hash #=> -910576647
- :name: <=>
  :arglist: obj <=> other -> 0 or nil
  :comment: Retorna 0 si obj === other, en otro caso nil.
- :name: class
  :arglist: obj.class    -> class
  :comment: |-
    Retorna la clase de <i>obj</i>. Éste método deberá ser llamado siempre con
    con un recibidor explicito, como <code>class</code> es también una palabra 
    reservada en Ruby.
    
       1.class      #=> Fixnum
       self.class   #=> Object
- :name: singleton_class
  :arglist: obj.singleton_class    -> class
  :comment: |-
    Retorna la clase singleton de <i>obj</i>.  Éste método crea una nueva clase
    singleton si <i>obj</i> no lo tiene.
    
    Si <i>obj</i> es <code>nil</code>, <code>true</code>, o
    <code>false</code>, este retorna NilClass, TrueClass, or FalseClass,
    respectivamente.
    Si <i>obj</i> es un Fixnum o un Symbol, este muestra un TypeError.
    
       Object.new.singleton_class  #=> #<Class:#<Object:0xb7ce1e24>>
       String.singleton_class      #=> #<Class:String>
       nil.singleton_class         #=> NilClass
- :name: clone
  :arglist: obj.clone -> an_object
  :comment: |-
    Produce un copia superficial de <i>obj</i>---las variables de instancia de
    <i>obj</i> son copiadas, pero no los objetos a los que hace referencia. Copia
    el estado actual de <i>obj</i>. Vea la referencia relacionada en 
    <code>Object#dup</code>.
    
       class Klass
          attr_accessor :str
       end
       s1 = Klass.new      #=> #<Klass:0x401b3a38>
       s1.str = "Hola"    #=> "Hola"
       s2 = s1.clone       #=> #<Klass:0x401b3998 @str="Hola">
       s2.str[1,4] = "i"   #=> "i"
       s1.inspect          #=> "#<Klass:0x401b3a38 @str=\"Hi\">"
       s2.inspect          #=> "#<Klass:0x401b3998 @str=\"Hi\">"
    
    Éste método puede tener un un comportamiento especifico de la clase.  Si lo tiene, este
    estará documentado debajo del #+initialize_copy+ de la clase.
- :name: dup
  :arglist: obj.dup -> an_object
  :comment: |-
    Produce uan copia superficial de <i>obj</i>---las variables de instancia de
    <i>obj</i> son copiadas, pero no los objetos de referencia.
    <code>dup</code> copia el estado actual de <i>obj</i>. Vea además
    en <code>Object#clone</code>. En general, <code>clone</code> y 
    <code>dup</code> pueden tener diferentes semánticas en clases descendientes.
    Mientras <code>clone</code> es usado para duplicar un objeto, incluyendo su
    estado interno, <code>dup</code> comunmente utiliza la clase del objeto 
    descendiente para crear una nueva instancia.
    
    Éste método puede tener un comportamiento expecifico de la clase.
    Si lo tiene, ese comportamiento estará documentando bano el método
    #+initialize_copy+ de clase.
- :name: taint
  :arglist: obj.taint -> obj
  :comment: |-
    Marca <i>obj</i> como marcado---si el nivel <code>$SAFE</code> 
    seteado correctamente,muchas llamadas al método que podría alterar el 
    funcionamiento entorno de los programas se negarán a aceptar cadenas 
    marcadas.
- :name: tainted?
  :arglist: obj.tainted?    -> true or false
  :comment: Retorna <code>true</code> si el objeto es marcado.
- :name: untaint
  :arglist: obj.untaint    -> obj
  :comment: Quita la marca de <i>obj</i>.
- :name: untrust
  :arglist: obj.untrust -> obj
  :comment: Marca <i>obj</i> como no confiable.
- :name: untrusted?
  :arglist: obj.untrusted?    -> true o false
  :comment: Retorna <code>true</code> si el objeto no es confiable.
- :name: trust
  :arglist: obj.trust    -> obj
  :comment: Quita la marca de no confiable de <i>obj</i>.
- :name: freeze
  :arglist: obj.freeze    -> obj
  :comment: |-
    Impide nuevas modificaiones a <i>obj</i>. Un
    <code>RuntimeError</code> será mostrado si se intenta una modificación.
    No hay forma de volver atras un objeto congelado. Vea también 
    <code>Object#frozen?</code>.
    
    Éste método retorna self.
    
       a = [ "a", "b", "c" ]
       a.freeze
       a << "z"
    
    <em>produce:</em>
    
       prog.rb:3:in `<<': cann't modify frozen array (RuntimeError)
        from prog.rb:3
- :name: frozen?
  :arglist: obj.frozen?    -> true o false
  :comment: |-
    Retorna el estado de si <i>obj</i> esta o no congelado.
    
       a = [ "a", "b", "c" ]
       a.freeze    #=> ["a", "b", "c"]
       a.frozen?   #=> true
- :name: to_s
  :arglist: obj.to_s    -> string
  :comment: |-
    Retorna un string representando <i>obj</i>. Por defecto
    <code>to_s</code> imprime la clase del objeto y un encoding de
    object id. Un caso especial, el valor del top-level object que es la
    el contexto de ejecución inicial de programas Ruby retorna ``main.''
- :name: inspect
  :arglist: obj.inspect   -> string
  :comment: |-
    Retorna un string contentiendo una representación humanamente legible de 
    <i>obj</i>. Si no es sobreescrito y no tiene variables de instancia, utiliza el
    método <code>to_s</code> para generar un string.
    <i>obj</i>.  Si no es sobreescrito , utiliza el método <code>to_s</code> para
    generar el string.
    
       [ 1, 2, 3..4, 'five' ].inspect   #=> "[1, 2, 3..4, \"five\"]"
       Time.new.inspect                 #=> "2008-03-08 19:43:39 +0900"
- :name: singleton_methods
  :arglist: obj.singleton_methods(all=true)    -> array
  :comment: |-
    Retorna un arreglo de los nombres de métodos singleton para <i>obj</i>.
    Si el parámetro opcional <i>all</i> es verdadero, la lista incluira
    métodos incluidos en módulos en <i>obj</i>.
    Solo métodos públicos y protegidos singleton son retornados.
    
       module Other
         def three() end
       end
    
       class Single
         def Single.four() end
       end
    
       a = Single.new
    
       def a.one()
       end
    
       class << a
         include Other
         def two()
         end
       end
    
       Single.singleton_methods    #=> [:four]
       a.singleton_methods(false)  #=> [:two, :one]
       a.singleton_methods         #=> [:two, :one, :three]
- :name: instance_variables
  :arglist: obj.instance_variables    -> array
  :comment: |-
    Returns an array of instance variable names for the receiver. Note
    that simply defining an accessor does not create the corresponding
    instance variable.
    
       class Fred
         attr_accessor :a1
         def initialize
           @iv = 3
         end
       end
       Fred.new.instance_variables   #=> [:@iv]
- :name: instance_variable_get
  :arglist: obj.instance_variable_get(symbol)    -> obj
  :comment: |-
    Returns the value of the given instance variable, or nil if the
    instance variable is not set. The <code>@</code> part of the
    variable name should be included for regular instance
    variables. Throws a <code>NameError</code> exception if the
    supplied symbol is not valid as an instance variable name.
    
       class Fred
         def initialize(p1, p2)
           @a, @b = p1, p2
         end
       end
       fred = Fred.new('cat', 99)
       fred.instance_variable_get(:@a)    #=> "cat"
       fred.instance_variable_get("@b")   #=> 99
- :name: instance_variable_set
  :arglist: obj.instance_variable_set(symbol, obj)    -> obj
  :comment: |-
    Sets the instance variable names by <i>symbol</i> to
    <i>object</i>, thereby frustrating the efforts of the class's
    author to attempt to provide proper encapsulation. The variable
    did not have to exist prior to this call.
    
       class Fred
         def initialize(p1, p2)
           @a, @b = p1, p2
         end
       end
       fred = Fred.new('cat', 99)
       fred.instance_variable_set(:@a, 'dog')   #=> "dog"
       fred.instance_variable_set(:@c, 'cat')   #=> "cat"
       fred.inspect                             #=> "#<Fred:0x401b3da8 @a=\"dog\", @b=99, @c=\"cat\">"
- :name: instance_variable_defined?
  :arglist: obj.instance_variable_defined?(symbol)    -> true or false
  :comment: |-
    Returns <code>true</code> if the given instance variable is
    defined in <i>obj</i>.
    
       class Fred
         def initialize(p1, p2)
           @a, @b = p1, p2
         end
       end
       fred = Fred.new('cat', 99)
       fred.instance_variable_defined?(:@a)    #=> true
       fred.instance_variable_defined?("@b")   #=> true
       fred.instance_variable_defined?("@c")   #=> false
- :name: remove_instance_variable
  :arglist: obj.remove_instance_variable(symbol)    -> obj
  :comment: |-
    Removes the named instance variable from <i>obj</i>, returning that
    variable's value.
    
       class Dummy
         attr_reader :var
         def initialize
           @var = 99
         end
         def remove
           remove_instance_variable(:@var)
         end
       end
       d = Dummy.new
       d.var      #=> 99
       d.remove   #=> 99
       d.var      #=> nil
- :name: instance_of?
  :arglist: obj.instance_of?(class)    -> true or false
  :comment: |-
    Returns <code>true</code> if <i>obj</i> is an instance of the given
    class. See also <code>Object#kind_of?</code>.
- :name: kind_of?
  :arglist: |-
    obj.is_a?(class)       -> true or false
    obj.kind_of?(class)    -> true or false
  :comment: |-
    Returns <code>true</code> if <i>class</i> is the class of
    <i>obj</i>, or if <i>class</i> is one of the superclasses of
    <i>obj</i> or modules included in <i>obj</i>.
    
       module M;    end
       class A
         include M
       end
       class B < A; end
       class C < B; end
       b = B.new
       b.instance_of? A   #=> false
       b.instance_of? B   #=> true
       b.instance_of? C   #=> false
       b.instance_of? M   #=> false
       b.kind_of? A       #=> true
       b.kind_of? B       #=> true
       b.kind_of? C       #=> false
       b.kind_of? M       #=> true
- :name: is_a?
  :arglist: |-
    obj.is_a?(class)       -> true or false
    obj.kind_of?(class)    -> true or false
  :comment: |-
    Returns <code>true</code> if <i>class</i> is the class of
    <i>obj</i>, or if <i>class</i> is one of the superclasses of
    <i>obj</i> or modules included in <i>obj</i>.
    
       module M;    end
       class A
         include M
       end
       class B < A; end
       class C < B; end
       b = B.new
       b.instance_of? A   #=> false
       b.instance_of? B   #=> true
       b.instance_of? C   #=> false
       b.instance_of? M   #=> false
       b.kind_of? A       #=> true
       b.kind_of? B       #=> true
       b.kind_of? C       #=> false
       b.kind_of? M       #=> true
- :name: tap
  :arglist: obj.tap{|x|...}    -> obj
  :comment: |-
    Yields <code>x</code> to the block, and then returns <code>x</code>.
    The primary purpose of this method is to "tap into" a method chain,
    in order to perform operations on intermediate results within the chain.
    
        (1..10)                .tap {|x| puts "original: #{x.inspect}"}
          .to_a                .tap {|x| puts "array: #{x.inspect}"}
          .select {|x| x%2==0} .tap {|x| puts "evens: #{x.inspect}"}
          .map { |x| x*x }     .tap {|x| puts "squares: #{x.inspect}"}
- :name: method
  :arglist: obj.method(sym)    -> method
  :comment: |-
    Looks up the named method as a receiver in <i>obj</i>, returning a
    <code>Method</code> object (or raising <code>NameError</code>). The
    <code>Method</code> object acts as a closure in <i>obj</i>'s object
    instance, so instance variables and the value of <code>self</code>
    remain available.
    
       class Demo
         def initialize(n)
           @iv = n
         end
         def hello()
           "Hello, @iv = #{@iv}"
         end
       end
    
       k = Demo.new(99)
       m = k.method(:hello)
       m.call   #=> "Hello, @iv = 99"
    
       l = Demo.new('Fred')
       m = l.method("hello")
       m.call   #=> "Hello, @iv = Fred"
- :name: public_method
  :arglist: obj.public_method(sym)    -> method
  :comment: Similar to _method_, searches public method only.
- :name: define_singleton_method
  :arglist: |-
    define_singleton_method(symbol, method) -> new_method
    define_singleton_method(symbol) { block } -> proc
  :comment: |-
    Defines a singleton method in the receiver. The _method_
    parameter can be a +Proc+, a +Method+ or an +UnboundMethod+ object.
    If a block is specified, it is used as the method body.
    
       class A
         class << self
           def class_name
             to_s
           end
         end
       end
       A.define_singleton_method(:who_am_i) do
         "I am: #{class_name}"
       end
       A.who_am_i   # ==> "I am: A"
    
       guy = "Bob"
       guy.define_singleton_method(:hello) { "#{self}: Hello there!" }
       guy.hello    #=>  "Bob: Hello there!"
- :name: send
  :arglist: |-
    obj.send(symbol [, args...])        -> obj
    obj.__send__(symbol [, args...])      -> obj
  :comment: |-
    Invokes the method identified by _symbol_, passing it any
    arguments specified. You can use <code>__send__</code> if the name
    +send+ clashes with an existing method in _obj_.
    
       class Klass
         def hello(*args)
           "Hello " + args.join(' ')
         end
       end
       k = Klass.new
       k.send :hello, "gentle", "readers"   #=> "Hello gentle readers"
- :name: public_send
  :arglist: obj.public_send(symbol [, args...])  -> obj
  :comment: |-
    Invokes the method identified by _symbol_, passing it any
    arguments specified. Unlike send, public_send calls public
    methods only.
    
       1.public_send(:puts, "hello")  # causes NoMethodError
- :name: respond_to?
  :arglist: obj.respond_to?(symbol, include_private=false) -> true or false
  :comment: |-
    Returns +true+ if _obj_ responds to the given
    method. Private methods are included in the search only if the
    optional second parameter evaluates to +true+.
    
    If the method is not implemented,
    as Process.fork on Windows, File.lchmod on GNU/Linux, etc.,
    false is returned.
    
    If the method is not defined, <code>respond_to_missing?</code>
    method is called and the result is returned.
- :name: respond_to_missing?
  :arglist: obj.respond_to_missing?(symbol, include_private) -> true or false
  :comment: |-
    Hook method to return whether the _obj_ can respond to _id_ method
    or not.
    
    See #respond_to?.
:class_methods: []

