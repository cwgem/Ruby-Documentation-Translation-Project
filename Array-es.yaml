--- 
:name: Array
:comment: |-
  Los arreglos son colecciones ordenadas de enteros-indexados de cualquier objeto.
  El índice de un arreglo comienza en 0, como en C o Java. Un índice negativo es
  asumido como el valor relativo desde el final del arreglo---esto es, un índice de -1
  indica el último elemento del arreglo, -2 es penúltimo
  elemento en el arreglo, y así sucesivamente.
:instance_methods: 
- :name: initialize_copy
  :arglist: ary.replace(other_ary)  -> ary
  :comment: |-
    Reemplaza los contenidos de +self+ con los contenidos de
    <i>other_ary</i>, truncando o expandiendo si es necesario.
    
       a = [ "a", "b", "c", "d", "e" ]
       a.replace([ "x", "y", "z" ])   #=> ["x", "y", "z"]
       a                              #=> ["x", "y", "z"]
- :name: inspect
  :arglist: |-
    ary.to_s -> string
    ary.inspect  -> string
  :comment: Crea una representación de tipo string de +self+.
- :name: to_a
  :arglist: ary.to_a     -> ary
  :comment: |-
    Retorna +self+. Si es llamado en una sub-clase de Array, convierte
    el recibidor a un objeto Array.
- :name: to_ary
  :arglist: ary.to_ary -> ary
  :comment: Retorna +self+.
- :name: frozen?
  :arglist: ary.frozen?  -> true or false
  :comment: |-
    Retorna <code>true</code> si este arreglo está congelado (o temporalmente congelado
    mientras está siendo ordenado).
- :name: ==
  :arglist: ary == other_ary   ->   bool
  :comment: |-
    Igualdad---Dos arreglos son iguales si contienen el mismo número
    de elementos y si cada elemento es igual a (según el 
    Object.==) el elemento correspondiente en el otro arreglo.
    
       [ "a", "c" ]    == [ "a", "c", 7 ]     #=> false
       [ "a", "c", 7 ] == [ "a", "c", 7 ]     #=> true
       [ "a", "c", 7 ] == [ "a", "d", "f" ]   #=> false
- :name: eql?
  :arglist: ary.eql?(other)  -> true or false
  :comment: |-
    Retorna <code>true</code> si +self+ y _other_ son el mismo objeto,
    o ambos son arreglos con el mismo contenido.
- :name: hash
  :arglist: ary.hash   -> fixnum
  :comment: |-
    Calcula un código hash para este arreglo. Dos arreglos con el mismo contenido
    tendrán el mismo código hash (y se compararán usando <code>eql?</code>).
- :name: "[]"
  :arglist: |-
    ary[index]                -> obj     or nil
    ary[start, length]        -> new_ary or nil
    ary[range]                -> new_ary or nil
    ary.slice(index)          -> obj     or nil
    ary.slice(start, length)  -> new_ary or nil
    ary.slice(range)          -> new_ary or nil
  :comment: |-
    Referencia del Elemento---Retorna el elemento en el _index_,
    o retorna un sub-arreglo que empieza con _start_ y
    continua para _length_ elementos, o retorna un sub-arreglo
    especificado por _range_.
    Índices negativos cuentan hacia atrás desde el final del arreglo
    (-1 es el último elemento). Retorna +nil+ si el índice
    (o el primer índice) están fuera del rango.
    
       a = [ "a", "b", "c", "d", "e" ]
       a[2] +  a[0] + a[1]    #=> "cab"
       a[6]                   #=> nil
       a[1, 2]                #=> [ "b", "c" ]
       a[1..3]                #=> [ "b", "c", "d" ]
       a[4..7]                #=> [ "e" ]
       a[6..10]               #=> nil
       a[-3, 3]               #=> [ "c", "d", "e" ]
       # special cases
       a[5]                   #=> nil
       a[5, 1]                #=> []
       a[5..10]               #=> []
- :name: "[]="
  :arglist: |-
    ary[index]         = obj                      ->  obj
    ary[start, length] = obj or other_ary or nil  ->  obj or other_ary or nil
    ary[range]         = obj or other_ary or nil  ->  obj or other_ary or nil
  :comment: |-
    Asignación de Elemento---Coloca el elemento en el _index_,
    o reemplaza un sub-arreglo que comienza en _start_ y
    continúa para _length_ elementos, o reemplaza un sub-arreglo
    especificado por el _range_. Si los índices son más grandes que
    la capacidad actual del arreglo, los arreglos crecerán
    automáticamente. Un índice negativo contará hacia atrás
    desde el final del arreglo. Se insertan elementos si _length_ es
    cero. Un +IndexError+ se produce si un índice negativo apunta
    más allá del principio del arreglo. Vea también
    <code>Array#push</code>, y <code>Array#unshift</code>.
    
       a = Array.new
       a[4] = "4";                 #=> [nil, nil, nil, nil, "4"]
       a[0, 3] = [ 'a', 'b', 'c' ] #=> ["a", "b", "c", nil, "4"]
       a[1..2] = [ 1, 2 ]          #=> ["a", 1, 2, nil, "4"]
       a[0, 2] = "?"               #=> ["?", 2, nil, "4"]
       a[0..2] = "A"               #=> ["A", "4"]
       a[-1]   = "Z"               #=> ["A", "Z"]
       a[1..-1] = nil              #=> ["A", nil]
       a[1..-1] = []               #=> ["A"]
- :name: at
  :arglist: ary.at(index)   ->   obj  or nil
  :comment: |-
    Retorna el elemento en _index_. Un
    índice negativo cuenta desde el final de +self+. Retorna +nil+
    si el índice está fuera del rango. Vea también <code>Array#[]</code>.
    
       a = [ "a", "b", "c", "d", "e" ]
       a.at(0)     #=> "a"
       a.at(-1)    #=> "e"
- :name: fetch
  :arglist: |-
    ary.fetch(index)                    -> obj
    ary.fetch(index, default )          -> obj
    ary.fetch(index) {|index| block }   -> obj
  :comment: |-
    Intenta retornar el elemento en la posición <i>index</i>. Si el índice
    permanece fuera del arreglo, el primer formulario arroja una
    excepción de tipo <code>IndexError</code>, el segundo formulario retorna
    <i>default</i>, y el tercer formulario retorna el valor de invocar 
    el bloque, pasando en el índice. Valores negativos de <i>index</i>
    cuentan desde el final del arreglo.
    
       a = [ 11, 22, 33, 44 ]
       a.fetch(1)               #=> 22
       a.fetch(-1)              #=> 44
       a.fetch(4, 'cat')        #=> "cat"
       a.fetch(4) { |i| i*i }   #=> 16
- :name: first
  :arglist: |-
    ary.first     ->   obj or nil
    ary.first(n)  ->   new_ary
  :comment: |-
    Retorna el primer elemento, o los primeros +n+ elementos, del arreglo.
    Si el arreglo está vacío, el primer formulario retorna <code>nil</code>, y el
    segundo formulario returna un arreglo vacío.
    
       a = [ "q", "r", "s", "t" ]
       a.first     #=> "q"
       a.first(2)  #=> ["q", "r"]
- :name: last
  :arglist: |-
    ary.last     ->  obj or nil
    ary.last(n)  ->  new_ary
  :comment: |-
    Retorna el último o últimos elementos de +self+. Si el arreglo está vacío,
    el primer formulario retorna <code>nil</code>.
    
       a = [ "w", "x", "y", "z" ]
       a.last     #=> "z"
       a.last(2)  #=> ["y", "z"]
- :name: concat
  :arglist: ary.concat(other_ary)   -> ary
  :comment: |-
    Añade los elementos de <i>other_ary</i> a +self+.
    
       [ "a", "b" ].concat( ["c", "d"] ) #=> [ "a", "b", "c", "d" ]
- :name: "<<"
  :arglist: ary << obj            -> ary
  :comment: |-
    Añade---Empuja el objeto dado hasta el final de este arreglo. Esta
    expresión devuelve el propio arreglo, así muchos añadidos
    pueden concatenarse juntos.
    
       [ 1, 2 ] << "c" << "d" << [ 3, 4 ]
               #=>  [ 1, 2, "c", "d", [ 3, 4 ] ]
- :name: push
  :arglist: ary.push(obj, ... )   -> ary
  :comment: |-
    Añade---Empuja los objetos dados hasta el final de este arreglo. Esta
    expresión devuelve el propio arreglo, así muchos añadidos
    pueden concatenarse juntos.
    
       a = [ "a", "b", "c" ]
       a.push("d", "e", "f")
               #=> ["a", "b", "c", "d", "e", "f"]
- :name: pop
  :arglist: |-
    ary.pop    -> obj or nil
    ary.pop(n) -> new_ary
  :comment: |-
    Borra el último elemento de +self+ y lo devuelve, o
    regresa <code>nil</code> si el arreglo está vacío.
    
    Si un número _n_ es dado, retorna un arreglo de los últimos n elementos
    (o menos) así como lo hace <code>array.slice!(-n, n)</code>.
    
       a = [ "a", "b", "c", "d" ]
       a.pop     #=> "d"
       a.pop(2)  #=> ["b", "c"]
       a         #=> ["a"]
- :name: shift
  :arglist: |-
    ary.shift    -> obj or nil
    ary.shift(n) -> new_ary
  :comment: |-
    Devuelve el primer elemento de +self+ y lo elimina (cambia todos
    los otros elementos por uno). Retorna <code>nil</code> si el arreglo
    está vacío.
    
    Si un número _n_ es dado, retorna un arreglo de los primeros n elementos
    (o menos) así como lo hace <code>array.slice!(0, n)</code>.
    
       args = [ "-m", "-q", "filename" ]
       args.shift     #=> "-m"
       args           #=> ["-q", "filename"]
    
       args = [ "-m", "-q", "filename" ]
       args.shift(2)  #=> ["-m", "-q"]
       args           #=> ["filename"]
- :name: unshift
  :arglist: ary.unshift(obj, ...)  -> ary
  :comment: |-
    Antepone objetos al frente de +self+,
    moviendo otros elementos hacia adelante.
    
       a = [ "b", "c", "d" ]
       a.unshift("a")   #=> ["a", "b", "c", "d"]
       a.unshift(1, 2)  #=> [ 1, 2, "a", "b", "c", "d"]
- :name: insert
  :arglist: ary.insert(index, obj...)  -> ary
  :comment: |-
    Inserta los valores dados antes del elemento con el índice dado
    (el cual podría ser negativo).
    
       a = %w{ a b c d }
       a.insert(2, 99)         #=> ["a", "b", 99, "c", "d"]
       a.insert(-2, 1, 2, 3)   #=> ["a", "b", 99, "c", 1, 2, 3, "d"]
- :name: each
  :arglist: |-
    ary.each {|item| block }   -> ary
    ary.each                   -> an_enumerator
  :comment: |-
    Llama <i>block</i> una vez por cada elemento en +self+, pasando ese
    elemento como un parámetro.
    
    Si el bloque no es dado, un enumerador es devuelto en su lugar.
    
       a = [ "a", "b", "c" ]
       a.each {|x| print x, " -- " }
    
    produce:
    
       a -- b -- c --
- :name: each_index
  :arglist: |-
    ary.each_index {|index| block }  -> ary
    ary.each_index                   -> an_enumerator
  :comment: |-
    Igual que <code>Array#each</code>, pero pasa el índice de el elemento 
    en lugar del elemento mismo.
    
    Si el bloque no es dado, un enumerador es devuelto en su lugar.
    
       a = [ "a", "b", "c" ]
       a.each_index {|x| print x, " -- " }
    
    produce:
    
       0 -- 1 -- 2 --
- :name: reverse_each
  :arglist: |-
    ary.reverse_each {|item| block }   -> ary
    ary.reverse_each                   -> an_enumerator
  :comment: |-
    Igual que <code>Array#each</code>, pero atraviesa +self+ en orden
    inverso.
    
       a = [ "a", "b", "c" ]
       a.reverse_each {|x| print x, " " }
    
    produce:
    
       c b a
- :name: length
  :arglist: ary.length -> int
  :comment: |-
    Retorna el número de elementos en +self+. Podría ser cero.
    
       [ 1, 2, 3, 4, 5 ].length   #=> 5
- :name: empty?
  :arglist: ary.empty?   -> true or false
  :comment: |-
    Retorna <code>true</code> si +self+ no contiene elementos.
    
       [].empty?   #=> true
- :name: find_index
  :arglist: |-
    ary.index(obj)           ->  int or nil
    ary.index {|item| block} ->  int or nil
    ary.index                ->  an_enumerator
  :comment: |-
    Retorna el índice el primer objeto en +self+ de tal que manera que el objeto es
    <code>==</code> a <i>obj</i>. Si un bloque es dato en lugar de un
    argumento, devuelve el índice del primer objeto cuyo <em>block</em> es verdadero.
    Retorna <code>nil</code> si no se encuentra ninguna coincidencia.
    Vea también <code>Array#rindex</code>.
    
    Si ningún bloque ni argumento es dado, un enumerador es devuelto en su lugar.
    
       a = [ "a", "b", "c" ]
       a.index("b")        #=> 1
       a.index("z")        #=> nil
       a.index{|x|x=="b"}  #=> 1
    
    Este es un alias de <code>#find_index</code>.
- :name: index
  :arglist: |-
    ary.index(obj)           ->  int or nil
    ary.index {|item| block} ->  int or nil
    ary.index                ->  an_enumerator
  :comment: |-
    Returns the index of the first object in +self+ such that the object is
    <code>==</code> to <i>obj</i>. If a block is given instead of an
    argument, returns index of first object for which <em>block</em> is true.
    Returns <code>nil</code> if no match is found.
    See also <code>Array#rindex</code>.
    
    If neither block nor argument is given, an enumerator is returned instead.
    
       a = [ "a", "b", "c" ]
       a.index("b")        #=> 1
       a.index("z")        #=> nil
       a.index{|x|x=="b"}  #=> 1
    
    This is an alias of <code>#find_index</code>.
- :name: rindex
  :arglist: |-
    ary.rindex(obj)           ->  int or nil
    ary.rindex {|item| block} ->  int or nil
    ary.rindex                ->  an_enumerator
  :comment: |-
    Returns the index of the last object in +self+
    <code>==</code> to <i>obj</i>. If a block is given instead of an
    argument, returns index of first object for which <em>block</em> is
    true, starting from the last object.
    Returns <code>nil</code> if no match is found.
    See also <code>Array#index</code>.
    
    If neither block nor argument is given, an enumerator is returned instead.
    
       a = [ "a", "b", "b", "b", "c" ]
       a.rindex("b")        #=> 3
       a.rindex("z")        #=> nil
       a.rindex{|x|x=="b"}  #=> 3
- :name: join
  :arglist: ary.join(sep=$,)    -> str
  :comment: |-
    Returns a string created by converting each element of the array to
    a string, separated by <i>sep</i>.
    
       [ "a", "b", "c" ].join        #=> "abc"
       [ "a", "b", "c" ].join("-")   #=> "a-b-c"
- :name: reverse
  :arglist: ary.reverse -> new_ary
  :comment: |-
    Returns a new array containing +self+'s elements in reverse order.
    
       [ "a", "b", "c" ].reverse   #=> ["c", "b", "a"]
       [ 1 ].reverse               #=> [1]
- :name: reverse!
  :arglist: ary.reverse!   -> ary
  :comment: |-
    Reverses +self+ in place.
    
       a = [ "a", "b", "c" ]
       a.reverse!       #=> ["c", "b", "a"]
       a                #=> ["c", "b", "a"]
- :name: rotate
  :arglist: ary.rotate(cnt=1) -> new_ary
  :comment: |-
    Returns new array by rotating +self+ so that the element at
    +cnt+ in +self+ is the first element of the new array. If +cnt+
    is negative then it rotates in the opposite direction.
    
       a = [ "a", "b", "c", "d" ]
       a.rotate         #=> ["b", "c", "d", "a"]
       a                #=> ["a", "b", "c", "d"]
       a.rotate(2)      #=> ["c", "d", "a", "b"]
       a.rotate(-3)     #=> ["b", "c", "d", "a"]
- :name: rotate!
  :arglist: ary.rotate!(cnt=1) -> ary
  :comment: |-
    Rotates +self+ in place so that the element at +cnt+ comes first,
    and returns +self+.  If +cnt+ is negative then it rotates in
    the opposite direction.
    
       a = [ "a", "b", "c", "d" ]
       a.rotate!        #=> ["b", "c", "d", "a"]
       a                #=> ["b", "c", "d", "a"]
       a.rotate!(2)     #=> ["d", "a", "b", "c"]
       a.rotate!(-3)    #=> ["a", "b", "c", "d"]
- :name: sort
  :arglist: |-
    ary.sort                   -> new_ary
    ary.sort {| a,b | block }  -> new_ary
  :comment: |-
    Returns a new array created by sorting +self+. Comparisons for
    the sort will be done using the <code><=></code> operator or using
    an optional code block. The block implements a comparison between
    <i>a</i> and <i>b</i>, returning -1, 0, or +1. See also
    <code>Enumerable#sort_by</code>.
    
       a = [ "d", "a", "e", "c", "b" ]
       a.sort                    #=> ["a", "b", "c", "d", "e"]
       a.sort {|x,y| y <=> x }   #=> ["e", "d", "c", "b", "a"]
- :name: sort!
  :arglist: |-
    ary.sort!                   -> ary
    ary.sort! {| a,b | block }  -> ary
  :comment: |-
    Sorts +self+. Comparisons for
    the sort will be done using the <code><=></code> operator or using
    an optional code block. The block implements a comparison between
    <i>a</i> and <i>b</i>, returning -1, 0, or +1. See also
    <code>Enumerable#sort_by</code>.
    
       a = [ "d", "a", "e", "c", "b" ]
       a.sort!                    #=> ["a", "b", "c", "d", "e"]
       a.sort! {|x,y| y <=> x }   #=> ["e", "d", "c", "b", "a"]
- :name: sort_by!
  :arglist: |-
    ary.sort_by! {| obj | block }    -> ary
    ary.sort_by!                     -> an_enumerator
  :comment: |-
    Sorts +self+ in place using a set of keys generated by mapping the
    values in +self+ through the given block.
    
    If no block is given, an enumerator is returned instead.
- :name: collect
  :arglist: |-
    ary.collect {|item| block }  -> new_ary
    ary.map     {|item| block }  -> new_ary
    ary.collect                  -> an_enumerator
    ary.map                      -> an_enumerator
  :comment: |-
    Invokes <i>block</i> once for each element of +self+. Creates a
    new array containing the values returned by the block.
    See also <code>Enumerable#collect</code>.
    
    If no block is given, an enumerator is returned instead.
    
       a = [ "a", "b", "c", "d" ]
       a.collect {|x| x + "!" }   #=> ["a!", "b!", "c!", "d!"]
       a                          #=> ["a", "b", "c", "d"]
- :name: collect!
  :arglist: |-
    ary.collect! {|item| block }   -> ary
    ary.map!     {|item| block }   -> ary
    ary.collect                    -> an_enumerator
    ary.map                        -> an_enumerator
  :comment: |-
    Invokes the block once for each element of +self+, replacing the
    element with the value returned by _block_.
    See also <code>Enumerable#collect</code>.
    
    If no block is given, an enumerator is returned instead.
    
       a = [ "a", "b", "c", "d" ]
       a.collect! {|x| x + "!" }
       a             #=>  [ "a!", "b!", "c!", "d!" ]
- :name: map
  :arglist: |-
    ary.collect {|item| block }  -> new_ary
    ary.map     {|item| block }  -> new_ary
    ary.collect                  -> an_enumerator
    ary.map                      -> an_enumerator
  :comment: |-
    Invokes <i>block</i> once for each element of +self+. Creates a
    new array containing the values returned by the block.
    See also <code>Enumerable#collect</code>.
    
    If no block is given, an enumerator is returned instead.
    
       a = [ "a", "b", "c", "d" ]
       a.collect {|x| x + "!" }   #=> ["a!", "b!", "c!", "d!"]
       a                          #=> ["a", "b", "c", "d"]
- :name: map!
  :arglist: |-
    ary.collect! {|item| block }   -> ary
    ary.map!     {|item| block }   -> ary
    ary.collect                    -> an_enumerator
    ary.map                        -> an_enumerator
  :comment: |-
    Invokes the block once for each element of +self+, replacing the
    element with the value returned by _block_.
    See also <code>Enumerable#collect</code>.
    
    If no block is given, an enumerator is returned instead.
    
       a = [ "a", "b", "c", "d" ]
       a.collect! {|x| x + "!" }
       a             #=>  [ "a!", "b!", "c!", "d!" ]
- :name: select
  :arglist: |-
    ary.select {|item| block } -> new_ary
    ary.select                 -> an_enumerator
  :comment: |-
    Invokes the block passing in successive elements from +self+,
    returning an array containing those elements for which the block
    returns a true value (equivalent to <code>Enumerable#select</code>).
    
    If no block is given, an enumerator is returned instead.
    
       a = %w{ a b c d e f }
       a.select {|v| v =~ /[aeiou]/}   #=> ["a", "e"]
- :name: select!
  :arglist: |-
    ary.select! {|item| block } -> new_ary or nil
    ary.select!                 -> an_enumerator
  :comment: |-
    Invokes the block passing in successive elements from
    +self+, deleting elements for which the block returns a
    false value. It returns +self+ if changes were made,
    otherwise it returns <code>nil</code>.
    See also <code>Array#keep_if</code>
    
    If no block is given, an enumerator is returned instead.
- :name: keep_if
  :arglist: |-
    ary.keep_if {|item| block } -> ary
    ary.keep_if                 -> an_enumerator
  :comment: |-
    Deletes every element of +self+ for which <i>block</i> evaluates
    to false.
    See also <code>Array#select!</code>
    
    If no block is given, an enumerator is returned instead.
    
       a = %w{ a b c d e f }
       a.keep_if {|v| v =~ /[aeiou]/}   #=> ["a", "e"]
- :name: values_at
  :arglist: ary.values_at(selector,... )  -> new_ary
  :comment: |-
    Returns an array containing the elements in
    +self+ corresponding to the given selector(s). The selectors
    may be either integer indices or ranges.
    See also <code>Array#select</code>.
    
       a = %w{ a b c d e f }
       a.values_at(1, 3, 5)
       a.values_at(1, 3, 5, 7)
       a.values_at(-1, -3, -5, -7)
       a.values_at(1..3, 2...5)
- :name: delete
  :arglist: |-
    ary.delete(obj)            -> obj or nil
    ary.delete(obj) { block }  -> obj or nil
  :comment: |-
    Deletes items from +self+ that are equal to <i>obj</i>.
    If any items are found, returns <i>obj</i>.   If
    the item is not found, returns <code>nil</code>. If the optional
    code block is given, returns the result of <i>block</i> if the item
    is not found.  (To remove <code>nil</code> elements and
    get an informative return value, use #compact!)
    
       a = [ "a", "b", "b", "b", "c" ]
       a.delete("b")                   #=> "b"
       a                               #=> ["a", "c"]
       a.delete("z")                   #=> nil
       a.delete("z") { "not found" }   #=> "not found"
- :name: delete_at
  :arglist: ary.delete_at(index)  -> obj or nil
  :comment: |-
    Deletes the element at the specified index, returning that element,
    or <code>nil</code> if the index is out of range. See also
    <code>Array#slice!</code>.
    
       a = ["ant", "bat", "cat", "dog"]
       a.delete_at(2)    #=> "cat"
       a                 #=> ["ant", "bat", "dog"]
       a.delete_at(99)   #=> nil
- :name: delete_if
  :arglist: |-
    ary.delete_if {|item| block }  -> ary
    ary.delete_if                  -> an_enumerator
  :comment: |-
    Deletes every element of +self+ for which <i>block</i> evaluates
    to true.
    See also <code>Array#reject!</code>
    
    If no block is given, an enumerator is returned instead.
    
       a = [ "a", "b", "c" ]
       a.delete_if {|x| x >= "b" }   #=> ["a"]
- :name: reject
  :arglist: |-
    ary.reject {|item| block }  -> new_ary
    ary.reject                  -> an_enumerator
  :comment: |-
    Returns a new array containing the items in +self+
    for which the block is not true.
    See also <code>Array#delete_if</code>
    
    If no block is given, an enumerator is returned instead.
- :name: reject!
  :arglist: |-
    ary.reject! {|item| block }  -> ary or nil
    ary.reject!                  -> an_enumerator
  :comment: |-
    Equivalent to <code>Array#delete_if</code>, deleting elements from
    +self+ for which the block evaluates to true, but returns
    <code>nil</code> if no changes were made.
    See also <code>Enumerable#reject</code> and <code>Array#delete_if</code>.
    
    If no block is given, an enumerator is returned instead.
- :name: zip
  :arglist: |-
    ary.zip(arg, ...)                   -> new_ary
    ary.zip(arg, ...) {| arr | block }  -> nil
  :comment: |-
    Converts any arguments to arrays, then merges elements of
    +self+ with corresponding elements from each argument. This
    generates a sequence of <code>self.size</code> <em>n</em>-element
    arrays, where <em>n</em> is one more that the count of arguments. If
    the size of any argument is less than <code>enumObj.size</code>,
    <code>nil</code> values are supplied. If a block is given, it is
    invoked for each output array, otherwise an array of arrays is
    returned.
    
       a = [ 4, 5, 6 ]
       b = [ 7, 8, 9 ]
       [1,2,3].zip(a, b)      #=> [[1, 4, 7], [2, 5, 8], [3, 6, 9]]
       [1,2].zip(a,b)         #=> [[1, 4, 7], [2, 5, 8]]
       a.zip([1,2],[8])       #=> [[4,1,8], [5,2,nil], [6,nil,nil]]
- :name: transpose
  :arglist: ary.transpose -> new_ary
  :comment: |-
    Assumes that +self+ is an array of arrays and transposes the
    rows and columns.
    
       a = [[1,2], [3,4], [5,6]]
       a.transpose   #=> [[1, 3, 5], [2, 4, 6]]
- :name: replace
  :arglist: ary.replace(other_ary)  -> ary
  :comment: |-
    Replaces the contents of +self+ with the contents of
    <i>other_ary</i>, truncating or expanding if necessary.
    
       a = [ "a", "b", "c", "d", "e" ]
       a.replace([ "x", "y", "z" ])   #=> ["x", "y", "z"]
       a                              #=> ["x", "y", "z"]
- :name: clear
  :arglist: ary.clear    -> ary
  :comment: |-
    Removes all elements from +self+.
    
       a = [ "a", "b", "c", "d", "e" ]
       a.clear    #=> [ ]
- :name: fill
  :arglist: |-
    ary.fill(obj)                                -> ary
    ary.fill(obj, start [, length])              -> ary
    ary.fill(obj, range )                        -> ary
    ary.fill {|index| block }                    -> ary
    ary.fill(start [, length] ) {|index| block } -> ary
    ary.fill(range) {|index| block }             -> ary
  :comment: |-
    The first three forms set the selected elements of +self+ (which
    may be the entire array) to <i>obj</i>. A <i>start</i> of
    <code>nil</code> is equivalent to zero. A <i>length</i> of
    <code>nil</code> is equivalent to <i>self.length</i>. The last three
    forms fill the array with the value of the block. The block is
    passed the absolute index of each element to be filled.
    Negative values of <i>start</i> count from the end of the array.
    
       a = [ "a", "b", "c", "d" ]
       a.fill("x")              #=> ["x", "x", "x", "x"]
       a.fill("z", 2, 2)        #=> ["x", "x", "z", "z"]
       a.fill("y", 0..1)        #=> ["y", "y", "z", "z"]
       a.fill {|i| i*i}         #=> [0, 1, 4, 9]
       a.fill(-2) {|i| i*i*i}   #=> [0, 1, 8, 27]
- :name: include?
  :arglist: ary.include?(obj)   -> true or false
  :comment: |-
    Returns <code>true</code> if the given object is present in
    +self+ (that is, if any object <code>==</code> <i>anObject</i>),
    <code>false</code> otherwise.
    
       a = [ "a", "b", "c" ]
       a.include?("b")   #=> true
       a.include?("z")   #=> false
- :name: <=>
  :arglist: ary <=> other_ary   ->  -1, 0, +1 or nil
  :comment: |-
    Comparison---Returns an integer (-1, 0,
    or +1) if this array is less than, equal to, or greater than
    <i>other_ary</i>.  Each object in each array is compared
    (using <=>). If any value isn't
    equal, then that inequality is the return value. If all the
    values found are equal, then the return is based on a
    comparison of the array lengths.  Thus, two arrays are
    ``equal'' according to <code>Array#<=></code> if and only if they have
    the same length and the value of each element is equal to the
    value of the corresponding element in the other array.
    
       [ "a", "a", "c" ]    <=> [ "a", "b", "c" ]   #=> -1
       [ 1, 2, 3, 4, 5, 6 ] <=> [ 1, 2 ]            #=> +1
- :name: slice
  :arglist: |-
    ary[index]                -> obj     or nil
    ary[start, length]        -> new_ary or nil
    ary[range]                -> new_ary or nil
    ary.slice(index)          -> obj     or nil
    ary.slice(start, length)  -> new_ary or nil
    ary.slice(range)          -> new_ary or nil
  :comment: |-
    Element Reference---Returns the element at _index_,
    or returns a subarray starting at _start_ and
    continuing for _length_ elements, or returns a subarray
    specified by _range_.
    Negative indices count backward from the end of the
    array (-1 is the last element). Returns +nil+ if the index
    (or starting index) are out of range.
    
       a = [ "a", "b", "c", "d", "e" ]
       a[2] +  a[0] + a[1]    #=> "cab"
       a[6]                   #=> nil
       a[1, 2]                #=> [ "b", "c" ]
       a[1..3]                #=> [ "b", "c", "d" ]
       a[4..7]                #=> [ "e" ]
       a[6..10]               #=> nil
       a[-3, 3]               #=> [ "c", "d", "e" ]
       # special cases
       a[5]                   #=> nil
       a[5, 1]                #=> []
       a[5..10]               #=> []
- :name: slice!
  :arglist: |-
    ary.slice!(index)         -> obj or nil
    ary.slice!(start, length) -> new_ary or nil
    ary.slice!(range)         -> new_ary or nil
  :comment: |-
    Deletes the element(s) given by an index (optionally with a length)
    or by a range. Returns the deleted object (or objects), or
    <code>nil</code> if the index is out of range.
    
       a = [ "a", "b", "c" ]
       a.slice!(1)     #=> "b"
       a               #=> ["a", "c"]
       a.slice!(-1)    #=> "c"
       a               #=> ["a"]
       a.slice!(100)   #=> nil
       a               #=> ["a"]
- :name: assoc
  :arglist: ary.assoc(obj)   -> new_ary  or  nil
  :comment: |-
    Searches through an array whose elements are also arrays
    comparing _obj_ with the first element of each contained array
    using obj.==.
    Returns the first contained array that matches (that
    is, the first associated array),
    or +nil+ if no match is found.
    See also <code>Array#rassoc</code>.
    
       s1 = [ "colors", "red", "blue", "green" ]
       s2 = [ "letters", "a", "b", "c" ]
       s3 = "foo"
       a  = [ s1, s2, s3 ]
       a.assoc("letters")  #=> [ "letters", "a", "b", "c" ]
       a.assoc("foo")      #=> nil
- :name: rassoc
  :arglist: ary.rassoc(obj) -> new_ary or nil
  :comment: |-
    Searches through the array whose elements are also arrays. Compares
    _obj_ with the second element of each contained array using
    <code>==</code>. Returns the first contained array that matches. See
    also <code>Array#assoc</code>.
    
       a = [ [ 1, "one"], [2, "two"], [3, "three"], ["ii", "two"] ]
       a.rassoc("two")    #=> [2, "two"]
       a.rassoc("four")   #=> nil
- :name: +
  :arglist: ary + other_ary   -> new_ary
  :comment: |-
    Concatenation---Returns a new array built by concatenating the
    two arrays together to produce a third array.
    
       [ 1, 2, 3 ] + [ 4, 5 ]    #=> [ 1, 2, 3, 4, 5 ]
- :name: "*"
  :arglist: |-
    ary * int     -> new_ary
    ary * str     -> new_string
  :comment: |-
    Repetition---With a String argument, equivalent to
    self.join(str). Otherwise, returns a new array
    built by concatenating the _int_ copies of +self+.
    
       [ 1, 2, 3 ] * 3    #=> [ 1, 2, 3, 1, 2, 3, 1, 2, 3 ]
       [ 1, 2, 3 ] * ","  #=> "1,2,3"
- :name: "-"
  :arglist: ary - other_ary    -> new_ary
  :comment: |-
    Array Difference---Returns a new array that is a copy of
    the original array, removing any items that also appear in
    <i>other_ary</i>. (If you need set-like behavior, see the
    library class Set.)
    
       [ 1, 1, 2, 2, 3, 3, 4, 5 ] - [ 1, 2, 4 ]  #=>  [ 3, 3, 5 ]
- :name: "&"
  :arglist: ary & other_ary      -> new_ary
  :comment: |-
    Set Intersection---Returns a new array
    containing elements common to the two arrays, with no duplicates.
    
       [ 1, 1, 3, 5 ] & [ 1, 2, 3 ]   #=> [ 1, 3 ]
- :name: "|"
  :arglist: ary | other_ary     -> new_ary
  :comment: |-
    Set Union---Returns a new array by joining this array with
    <i>other_ary</i>, removing duplicates.
    
       [ "a", "b", "c" ] | [ "c", "d", "a" ]
              #=> [ "a", "b", "c", "d" ]
- :name: uniq
  :arglist: ary.uniq   -> new_ary
  :comment: |-
    Returns a new array by removing duplicate values in +self+.
    
       a = [ "a", "a", "b", "b", "c" ]
       a.uniq   #=> ["a", "b", "c"]
       c = [ "a:def", "a:xyz", "b:abc", "b:xyz", "c:jkl" ]
       c.uniq {|s| s[/^\w+/]}  #=> [ "a:def", "b:abc", "c:jkl" ]
- :name: uniq!
  :arglist: ary.uniq! -> ary or nil
  :comment: |-
    Removes duplicate elements from +self+.
    Returns <code>nil</code> if no changes are made (that is, no
    duplicates are found).
    
       a = [ "a", "a", "b", "b", "c" ]
       a.uniq!   #=> ["a", "b", "c"]
       b = [ "a", "b", "c" ]
       b.uniq!   #=> nil
       c = [ "a:def", "a:xyz", "b:abc", "b:xyz", "c:jkl" ]
       c.uniq! {|s| s[/^\w+/]}  #=> [ "a:def", "b:abc", "c:jkl" ]
- :name: compact
  :arglist: ary.compact     -> new_ary
  :comment: |-
    Returns a copy of +self+ with all +nil+ elements removed.
    
       [ "a", nil, "b", nil, "c", nil ].compact
                         #=> [ "a", "b", "c" ]
- :name: compact!
  :arglist: ary.compact!    -> ary  or  nil
  :comment: |-
    Removes +nil+ elements from the array.
    Returns +nil+ if no changes were made, otherwise returns
    <i>ary</i>.
    
       [ "a", nil, "b", nil, "c" ].compact! #=> [ "a", "b", "c" ]
       [ "a", "b", "c" ].compact!           #=> nil
- :name: flatten
  :arglist: |-
    ary.flatten -> new_ary
    ary.flatten(level) -> new_ary
  :comment: |-
    Returns a new array that is a one-dimensional flattening of this
    array (recursively). That is, for every element that is an array,
    extract its elements into the new array.  If the optional
    <i>level</i> argument determines the level of recursion to flatten.
    
       s = [ 1, 2, 3 ]           #=> [1, 2, 3]
       t = [ 4, 5, 6, [7, 8] ]   #=> [4, 5, 6, [7, 8]]
       a = [ s, t, 9, 10 ]       #=> [[1, 2, 3], [4, 5, 6, [7, 8]], 9, 10]
       a.flatten                 #=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
       a = [ 1, 2, [3, [4, 5] ] ]
       a.flatten(1)              #=> [1, 2, 3, [4, 5]]
- :name: flatten!
  :arglist: |-
    ary.flatten!        -> ary or nil
    ary.flatten!(level) -> array or nil
  :comment: |-
    Flattens +self+ in place.
    Returns <code>nil</code> if no modifications were made (i.e.,
    <i>ary</i> contains no subarrays.)  If the optional <i>level</i>
    argument determines the level of recursion to flatten.
    
       a = [ 1, 2, [3, [4, 5] ] ]
       a.flatten!   #=> [1, 2, 3, 4, 5]
       a.flatten!   #=> nil
       a            #=> [1, 2, 3, 4, 5]
       a = [ 1, 2, [3, [4, 5] ] ]
       a.flatten!(1) #=> [1, 2, 3, [4, 5]]
- :name: count
  :arglist: |-
    ary.count      -> int
    ary.count(obj) -> int
    ary.count { |item| block }  -> int
  :comment: |-
    Returns the number of elements.  If an argument is given, counts
    the number of elements which equals to <i>obj</i>.  If a block is
    given, counts the number of elements yielding a true value.
    
       ary = [1, 2, 4, 2]
       ary.count             #=> 4
       ary.count(2)          #=> 2
       ary.count{|x|x%2==0}  #=> 3
- :name: shuffle!
  :arglist: |-
    ary.shuffle!              -> ary
    ary.shuffle!(random: rng) -> ary
  :comment: |-
    Shuffles elements in +self+ in place.
    If +rng+ is given, it will be used as the random number generator.
- :name: shuffle
  :arglist: |-
    ary.shuffle              -> new_ary
    ary.shuffle(random: rng) -> new_ary
  :comment: |-
    Returns a new array with elements of this array shuffled.
    
       a = [ 1, 2, 3 ]           #=> [1, 2, 3]
       a.shuffle                 #=> [2, 3, 1]
    
    If +rng+ is given, it will be used as the random number generator.
    
       a.shuffle(random: Random.new(1))  #=> [1, 3, 2]
- :name: sample
  :arglist: |-
    ary.sample                  -> obj
    ary.sample(random: rng)     -> obj
    ary.sample(n)               -> new_ary
    ary.sample(n, random: rng)  -> new_ary
  :comment: |-
    Choose a random element or +n+ random elements from the array. The elements
    are chosen by using random and unique indices into the array in order to
    ensure that an element doesn't repeat itself unless the array already
    contained duplicate elements. If the array is empty the first form returns
    <code>nil</code> and the second form returns an empty array.
    
    If +rng+ is given, it will be used as the random number generator.
- :name: cycle
  :arglist: |-
    ary.cycle(n=nil) {|obj| block }  -> nil
    ary.cycle(n=nil)                 -> an_enumerator
  :comment: |-
    Calls <i>block</i> for each element repeatedly _n_ times or
    forever if none or +nil+ is given.  If a non-positive number is
    given or the array is empty, does nothing.  Returns +nil+ if the
    loop has finished without getting interrupted.
    
    If no block is given, an enumerator is returned instead.
    
       a = ["a", "b", "c"]
       a.cycle {|x| puts x }  # print, a, b, c, a, b, c,.. forever.
       a.cycle(2) {|x| puts x }  # print, a, b, c, a, b, c.
- :name: permutation
  :arglist: |-
    ary.permutation { |p| block }          -> ary
    ary.permutation                        -> an_enumerator
    ary.permutation(n) { |p| block }       -> ary
    ary.permutation(n)                     -> an_enumerator
  :comment: |-
    When invoked with a block, yield all permutations of length <i>n</i>
    of the elements of <i>ary</i>, then return the array itself.
    If <i>n</i> is not specified, yield all permutations of all elements.
    The implementation makes no guarantees about the order in which
    the permutations are yielded.
    
    If no block is given, an enumerator is returned instead.
    
    Examples:
    
        a = [1, 2, 3]
        a.permutation.to_a     #=> [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
        a.permutation(1).to_a  #=> [[1],[2],[3]]
        a.permutation(2).to_a  #=> [[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]]
        a.permutation(3).to_a  #=> [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
        a.permutation(0).to_a  #=> [[]] # one permutation of length 0
        a.permutation(4).to_a  #=> []   # no permutations of length 4
- :name: combination
  :arglist: |-
    ary.combination(n) { |c| block }    -> ary
    ary.combination(n)                  -> an_enumerator
  :comment: |-
    When invoked with a block, yields all combinations of length <i>n</i>
    of elements from <i>ary</i> and then returns <i>ary</i> itself.
    The implementation makes no guarantees about the order in which
    the combinations are yielded.
    
    If no block is given, an enumerator is returned instead.
    
    Examples:
    
        a = [1, 2, 3, 4]
        a.combination(1).to_a  #=> [[1],[2],[3],[4]]
        a.combination(2).to_a  #=> [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]
        a.combination(3).to_a  #=> [[1,2,3],[1,2,4],[1,3,4],[2,3,4]]
        a.combination(4).to_a  #=> [[1,2,3,4]]
        a.combination(0).to_a  #=> [[]] # one combination of length 0
        a.combination(5).to_a  #=> []   # no combinations of length 5
- :name: repeated_permutation
  :arglist: |-
    ary.repeated_permutation(n) { |p| block } -> ary
    ary.repeated_permutation(n)               -> an_enumerator
  :comment: |-
    When invoked with a block, yield all repeated permutations of length
    <i>n</i> of the elements of <i>ary</i>, then return the array itself.
    The implementation makes no guarantees about the order in which
    the repeated permutations are yielded.
    
    If no block is given, an enumerator is returned instead.
    
    Examples:
    
        a = [1, 2]
        a.repeated_permutation(1).to_a  #=> [[1], [2]]
        a.repeated_permutation(2).to_a  #=> [[1,1],[1,2],[2,1],[2,2]]
        a.repeated_permutation(3).to_a  #=> [[1,1,1],[1,1,2],[1,2,1],[1,2,2],
                                        #    [2,1,1],[2,1,2],[2,2,1],[2,2,2]]
        a.repeated_permutation(0).to_a  #=> [[]] # one permutation of length 0
- :name: repeated_combination
  :arglist: |-
    ary.repeated_combination(n) { |c| block } -> ary
    ary.repeated_combination(n)               -> an_enumerator
  :comment: |-
    When invoked with a block, yields all repeated combinations of
    length <i>n</i> of elements from <i>ary</i> and then returns
    <i>ary</i> itself.
    The implementation makes no guarantees about the order in which
    the repeated combinations are yielded.
    
    If no block is given, an enumerator is returned instead.
    
    Examples:
    
        a = [1, 2, 3]
        a.repeated_combination(1).to_a  #=> [[1], [2], [3]]
        a.repeated_combination(2).to_a  #=> [[1,1],[1,2],[1,3],[2,2],[2,3],[3,3]]
        a.repeated_combination(3).to_a  #=> [[1,1,1],[1,1,2],[1,1,3],[1,2,2],[1,2,3],
                                        #    [1,3,3],[2,2,2],[2,2,3],[2,3,3],[3,3,3]]
        a.repeated_combination(4).to_a  #=> [[1,1,1,1],[1,1,1,2],[1,1,1,3],[1,1,2,2],[1,1,2,3],
                                        #    [1,1,3,3],[1,2,2,2],[1,2,2,3],[1,2,3,3],[1,3,3,3],
                                        #    [2,2,2,2],[2,2,2,3],[2,2,3,3],[2,3,3,3],[3,3,3,3]]
        a.repeated_combination(0).to_a  #=> [[]] # one combination of length 0
- :name: product
  :arglist: |-
    ary.product(other_ary, ...)                -> new_ary
    ary.product(other_ary, ...) { |p| block }  -> ary
  :comment: |-
    Returns an array of all combinations of elements from all arrays,
    The length of the returned array is the product of the length
    of +self+ and the argument arrays.
    If given a block, <i>product</i> will yield all combinations
    and return +self+ instead.
    
       [1,2,3].product([4,5])     #=> [[1,4],[1,5],[2,4],[2,5],[3,4],[3,5]]
       [1,2].product([1,2])       #=> [[1,1],[1,2],[2,1],[2,2]]
       [1,2].product([3,4],[5,6]) #=> [[1,3,5],[1,3,6],[1,4,5],[1,4,6],
                                  #     [2,3,5],[2,3,6],[2,4,5],[2,4,6]]
       [1,2].product()            #=> [[1],[2]]
       [1,2].product([])          #=> []
- :name: take
  :arglist: ary.take(n)               -> new_ary
  :comment: |-
    Returns first n elements from <i>ary</i>.
    
       a = [1, 2, 3, 4, 5, 0]
       a.take(3)             #=> [1, 2, 3]
- :name: take_while
  :arglist: |-
    ary.take_while {|arr| block }   -> new_ary
    ary.take_while                  -> an_enumerator
  :comment: |-
    Passes elements to the block until the block returns +nil+ or +false+,
    then stops iterating and returns an array of all prior elements.
    
    If no block is given, an enumerator is returned instead.
    
       a = [1, 2, 3, 4, 5, 0]
       a.take_while {|i| i < 3 }   #=> [1, 2]
- :name: drop
  :arglist: ary.drop(n)               -> new_ary
  :comment: |-
    Drops first n elements from +ary+ and returns the rest of
    the elements in an array.
    
       a = [1, 2, 3, 4, 5, 0]
       a.drop(3)             #=> [4, 5, 0]
- :name: drop_while
  :arglist: |-
    ary.drop_while {|arr| block }   -> new_ary
    ary.drop_while                  -> an_enumerator
  :comment: |-
    Drops elements up to, but not including, the first element for
    which the block returns +nil+ or +false+ and returns an array
    containing the remaining elements.
    
    If no block is given, an enumerator is returned instead.
    
       a = [1, 2, 3, 4, 5, 0]
       a.drop_while {|i| i < 3 }   #=> [3, 4, 5, 0]
- :name: to_s
  :arglist: to_s()
  :comment: ""
- :name: size
  :arglist: size()
  :comment: ""
- :name: pack
  :arglist: arr.pack ( aTemplateString ) -> aBinaryString
  :comment: |-
    Packs the contents of <i>arr</i> into a binary sequence according to
    the directives in <i>aTemplateString</i> (see the table below)
    Directives ``A,'' ``a,'' and ``Z'' may be followed by a count,
    which gives the width of the resulting field. The remaining
    directives also may take a count, indicating the number of array
    elements to convert. If the count is an asterisk
    (``<code>*</code>''), all remaining array elements will be
    converted. Any of the directives ``<code>sSiIlL</code>'' may be
    followed by an underscore (``<code>_</code>'') or
    exclamation mark (``<code>!</code>'') to use the underlying
    platform's native size for the specified type; otherwise, they use a
    platform-independent size. Spaces are ignored in the template
    string. See also <code>String#unpack</code>.
    
       a = [ "a", "b", "c" ]
       n = [ 65, 66, 67 ]
       a.pack("A3A3A3")   #=> "a  b  c  "
       a.pack("a3a3a3")   #=> "a\000\000b\000\000c\000\000"
       n.pack("ccc")      #=> "ABC"
    
    Directives for +pack+.
    
     Integer      | Array   |
     Directive    | Element | Meaning
     ---------------------------------------------------------------------------
        C         | Integer | 8-bit unsigned (unsigned char)
        S         | Integer | 16-bit unsigned, native endian (uint16_t)
        L         | Integer | 32-bit unsigned, native endian (uint32_t)
        Q         | Integer | 64-bit unsigned, native endian (uint64_t)
                  |         |
        c         | Integer | 8-bit signed (signed char)
        s         | Integer | 16-bit signed, native endian (int16_t)
        l         | Integer | 32-bit signed, native endian (int32_t)
        q         | Integer | 64-bit signed, native endian (int64_t)
                  |         |
        S_, S!    | Integer | unsigned short, native endian
        I, I_, I! | Integer | unsigned int, native endian
        L_, L!    | Integer | unsigned long, native endian
                  |         |
        s_, s!    | Integer | signed short, native endian
        i, i_, i! | Integer | signed int, native endian
        l_, l!    | Integer | signed long, native endian
                  |         |
        S> L> Q>  | Integer | same as the directives without ">" except
        s> l> q>  |         | big endian
        S!> I!>   |         | (available since Ruby 1.9.3)
        L!>       |         | "S>" is same as "n"
        s!> i!>   |         | "L>" is same as "N"
        l!>       |         |
                  |         |
        S< L< Q<  | Integer | same as the directives without "<" except
        s< l< q<  |         | little endian
        S!< I!<   |         | (available since Ruby 1.9.3)
        L!<       |         | "S<" is same as "v"
        s!< i!<   |         | "L<" is same as "V"
        l!<       |         |
                  |         |
        n         | Integer | 16-bit unsigned, network (big-endian) byte order
        N         | Integer | 32-bit unsigned, network (big-endian) byte order
        v         | Integer | 16-bit unsigned, VAX (little-endian) byte order
        V         | Integer | 32-bit unsigned, VAX (little-endian) byte order
                  |         |
        U         | Integer | UTF-8 character
        w         | Integer | BER-compressed integer
    
     Float        |         |
     Directive    |         | Meaning
     ---------------------------------------------------------------------------
        D, d      | Float   | double-precision, native format
        F, f      | Float   | single-precision, native format
        E         | Float   | double-precision, little-endian byte order
        e         | Float   | single-precision, little-endian byte order
        G         | Float   | double-precision, network (big-endian) byte order
        g         | Float   | single-precision, network (big-endian) byte order
    
     String       |         |
     Directive    |         | Meaning
     ---------------------------------------------------------------------------
        A         | String  | arbitrary binary string (space padded, count is width)
        a         | String  | arbitrary binary string (null padded, count is width)
        Z         | String  | same as ``a'', except that null is added with *
        B         | String  | bit string (MSB first)
        b         | String  | bit string (LSB first)
        H         | String  | hex string (high nibble first)
        h         | String  | hex string (low nibble first)
        u         | String  | UU-encoded string
        M         | String  | quoted printable, MIME encoding (see RFC2045)
        m         | String  | base64 encoded string (see RFC 2045, count is width)
                  |         | (if count is 0, no line feed are added, see RFC 4648)
        P         | String  | pointer to a structure (fixed-length string)
        p         | String  | pointer to a null-terminated string
    
     Misc.        |         |
     Directive    |         | Meaning
     ---------------------------------------------------------------------------
        @         | ---     | moves to absolute position
        X         | ---     | back up a byte
        x         | ---     | null byte
:class_methods: 
- :name: "[]"
  :arglist: "[](*args)"
  :comment: |-
    Returns a new array populated with the given objects.
    
      Array.[]( 1, 'a', /^A/ )
      Array[ 1, 'a', /^A/ ]
      [ 1, 'a', /^A/ ]
- :name: try_convert
  :arglist: Array.try_convert(obj) -> array or nil
  :comment: |-
    Try to convert <i>obj</i> into an array, using +to_ary+ method.
    Returns converted array or +nil+ if <i>obj</i> cannot be converted
    for any reason. This method can be used to check if an argument is an
    array.
    
       Array.try_convert([1])   #=> [1]
       Array.try_convert("1")   #=> nil
    
       if tmp = Array.try_convert(arg)
         # the argument is an array
       elsif tmp = String.try_convert(arg)
         # the argument is a string
       end
- :name: new
  :arglist: |-
    Array.new(size=0, obj=nil)
    Array.new(array)
    Array.new(size) {|index| block }
  :comment: |-
    Returns a new array. In the first form, the new array is
    empty. In the second it is created with _size_ copies of _obj_
    (that is, _size_ references to the same
    _obj_). The third form creates a copy of the array
    passed as a parameter (the array is generated by calling
    to_ary  on the parameter). In the last form, an array
    of the given size is created. Each element in this array is
    calculated by passing the element's index to the given block and
    storing the return value.
    
       Array.new
       Array.new(2)
       Array.new(5, "A")
    
       # only one copy of the object is created
       a = Array.new(2, Hash.new)
       a[0]['cat'] = 'feline'
       a
       a[1]['cat'] = 'Felix'
       a
    
       # here multiple copies are created
       a = Array.new(2) { Hash.new }
       a[0]['cat'] = 'feline'
       a
    
       squares = Array.new(5) {|i| i*i}
       squares
    
       copy = Array.new(squares)
