--- 
:name: Array
:comment: |-
  Los arreglos son colecciones ordenadas de enteros-indexados de cualquier objeto.
  El índice de un arreglo comienza en 0, como en C o Java. Un índice negativo es
  asumido como el valor relativo desde el final del arreglo---esto es, un índice de -1
  indica el último elemento del arreglo, -2 es penúltimo
  elemento en el arreglo, y así sucesivamente.
:instance_methods: 
- :name: initialize_copy
  :arglist: ary.replace(other_ary)  -> ary
  :comment: |-
    Reemplaza los contenidos de +self+ con los contenidos de
    <i>other_ary</i>, truncando o expandiendo si es necesario.
    
       a = [ "a", "b", "c", "d", "e" ]
       a.replace([ "x", "y", "z" ])   #=> ["x", "y", "z"]
       a                              #=> ["x", "y", "z"]
- :name: inspect
  :arglist: |-
    ary.to_s -> string
    ary.inspect  -> string
  :comment: Crea una representación de tipo string de +self+.
- :name: to_a
  :arglist: ary.to_a     -> ary
  :comment: |-
    Retorna +self+. Si es llamado en una sub-clase de Array, convierte
    el recibidor a un objeto Array.
- :name: to_ary
  :arglist: ary.to_ary -> ary
  :comment: Retorna +self+.
- :name: frozen?
  :arglist: ary.frozen?  -> true or false
  :comment: |-
    Retorna <code>true</code> si este arreglo está congelado (o temporalmente congelado
    mientras está siendo ordenado).
- :name: ==
  :arglist: ary == other_ary   ->   bool
  :comment: |-
    Igualdad---Dos arreglos son iguales si contienen el mismo número
    de elementos y si cada elemento es igual a (según el 
    Object.==) el elemento correspondiente en el otro arreglo.
    
       [ "a", "c" ]    == [ "a", "c", 7 ]     #=> false
       [ "a", "c", 7 ] == [ "a", "c", 7 ]     #=> true
       [ "a", "c", 7 ] == [ "a", "d", "f" ]   #=> false
- :name: eql?
  :arglist: ary.eql?(other)  -> true or false
  :comment: |-
    Retorna <code>true</code> si +self+ y _other_ son el mismo objeto,
    o ambos son arreglos con el mismo contenido.
- :name: hash
  :arglist: ary.hash   -> fixnum
  :comment: |-
    Calcula un código hash para este arreglo. Dos arreglos con el mismo contenido
    tendrán el mismo código hash (y se compararán usando <code>eql?</code>).
- :name: "[]"
  :arglist: |-
    ary[index]                -> obj     or nil
    ary[start, length]        -> new_ary or nil
    ary[range]                -> new_ary or nil
    ary.slice(index)          -> obj     or nil
    ary.slice(start, length)  -> new_ary or nil
    ary.slice(range)          -> new_ary or nil
  :comment: |-
    Referencia del Elemento---Retorna el elemento en el _index_,
    o retorna un sub-arreglo que empieza con _start_ y
    continua para _length_ elementos, o retorna un sub-arreglo
    especificado por _range_.
    Índices negativos cuentan hacia atrás desde el final del arreglo
    (-1 es el último elemento). Retorna +nil+ si el índice
    (o el primer índice) están fuera del rango.
    
       a = [ "a", "b", "c", "d", "e" ]
       a[2] +  a[0] + a[1]    #=> "cab"
       a[6]                   #=> nil
       a[1, 2]                #=> [ "b", "c" ]
       a[1..3]                #=> [ "b", "c", "d" ]
       a[4..7]                #=> [ "e" ]
       a[6..10]               #=> nil
       a[-3, 3]               #=> [ "c", "d", "e" ]
       # Casos especiales
       a[5]                   #=> nil
       a[5, 1]                #=> []
       a[5..10]               #=> []
- :name: "[]="
  :arglist: |-
    ary[index]         = obj                      ->  obj
    ary[start, length] = obj or other_ary or nil  ->  obj or other_ary or nil
    ary[range]         = obj or other_ary or nil  ->  obj or other_ary or nil
  :comment: |-
    Asignación de Elemento---Coloca el elemento en el _index_,
    o reemplaza un sub-arreglo que comienza en _start_ y
    continúa para _length_ elementos, o reemplaza un sub-arreglo
    especificado por el _range_. Si los índices son más grandes que
    la capacidad actual del arreglo, los arreglos crecerán
    automáticamente. Un índice negativo contará hacia atrás
    desde el final del arreglo. Se insertan elementos si _length_ es
    cero. Un +IndexError+ se produce si un índice negativo apunta
    más allá del principio del arreglo. Vea también
    <code>Array#push</code>, y <code>Array#unshift</code>.
    
       a = Array.new
       a[4] = "4";                 #=> [nil, nil, nil, nil, "4"]
       a[0, 3] = [ 'a', 'b', 'c' ] #=> ["a", "b", "c", nil, "4"]
       a[1..2] = [ 1, 2 ]          #=> ["a", 1, 2, nil, "4"]
       a[0, 2] = "?"               #=> ["?", 2, nil, "4"]
       a[0..2] = "A"               #=> ["A", "4"]
       a[-1]   = "Z"               #=> ["A", "Z"]
       a[1..-1] = nil              #=> ["A", nil]
       a[1..-1] = []               #=> ["A"]
- :name: at
  :arglist: ary.at(index)   ->   obj  or nil
  :comment: |-
    Retorna el elemento en _index_. Un
    índice negativo cuenta desde el final de +self+. Retorna +nil+
    si el índice está fuera del rango. Vea también <code>Array#[]</code>.
    
       a = [ "a", "b", "c", "d", "e" ]
       a.at(0)     #=> "a"
       a.at(-1)    #=> "e"
- :name: fetch
  :arglist: |-
    ary.fetch(index)                    -> obj
    ary.fetch(index, default )          -> obj
    ary.fetch(index) {|index| block }   -> obj
  :comment: |-
    Intenta retornar el elemento en la posición <i>index</i>. Si el índice
    permanece fuera del arreglo, el primer formulario arroja una
    excepción de tipo <code>IndexError</code>, el segundo formulario retorna
    <i>default</i>, y el tercer formulario retorna el valor de invocar 
    el bloque, pasando en el índice. Valores negativos de <i>index</i>
    cuentan desde el final del arreglo.
    
       a = [ 11, 22, 33, 44 ]
       a.fetch(1)               #=> 22
       a.fetch(-1)              #=> 44
       a.fetch(4, 'cat')        #=> "cat"
       a.fetch(4) { |i| i*i }   #=> 16
- :name: first
  :arglist: |-
    ary.first     ->   obj or nil
    ary.first(n)  ->   new_ary
  :comment: |-
    Retorna el primer elemento, o los primeros +n+ elementos, del arreglo.
    Si el arreglo está vacío, el primer formulario retorna <code>nil</code>, y el
    segundo formulario returna un arreglo vacío.
    
       a = [ "q", "r", "s", "t" ]
       a.first     #=> "q"
       a.first(2)  #=> ["q", "r"]
- :name: last
  :arglist: |-
    ary.last     ->  obj or nil
    ary.last(n)  ->  new_ary
  :comment: |-
    Retorna el último o últimos elementos de +self+. Si el arreglo está vacío,
    el primer formulario retorna <code>nil</code>.
    
       a = [ "w", "x", "y", "z" ]
       a.last     #=> "z"
       a.last(2)  #=> ["y", "z"]
- :name: concat
  :arglist: ary.concat(other_ary)   -> ary
  :comment: |-
    Añade los elementos de <i>other_ary</i> a +self+.
    
       [ "a", "b" ].concat( ["c", "d"] ) #=> [ "a", "b", "c", "d" ]
- :name: "<<"
  :arglist: ary << obj            -> ary
  :comment: |-
    Añade---Empuja el objeto dado hasta el final de este arreglo. Esta
    expresión devuelve el propio arreglo, así muchos añadidos
    pueden concatenarse juntos.
    
       [ 1, 2 ] << "c" << "d" << [ 3, 4 ]
               #=>  [ 1, 2, "c", "d", [ 3, 4 ] ]
- :name: push
  :arglist: ary.push(obj, ... )   -> ary
  :comment: |-
    Añade---Empuja los objetos dados hasta el final de este arreglo. Esta
    expresión devuelve el propio arreglo, así muchos añadidos
    pueden concatenarse juntos.
    
       a = [ "a", "b", "c" ]
       a.push("d", "e", "f")
               #=> ["a", "b", "c", "d", "e", "f"]
- :name: pop
  :arglist: |-
    ary.pop    -> obj or nil
    ary.pop(n) -> new_ary
  :comment: |-
    Borra el último elemento de +self+ y lo devuelve, o
    regresa <code>nil</code> si el arreglo está vacío.
    
    Si un número _n_ es dado, retorna un arreglo de los últimos n elementos
    (o menos) así como lo hace <code>array.slice!(-n, n)</code>.
    
       a = [ "a", "b", "c", "d" ]
       a.pop     #=> "d"
       a.pop(2)  #=> ["b", "c"]
       a         #=> ["a"]
- :name: shift
  :arglist: |-
    ary.shift    -> obj or nil
    ary.shift(n) -> new_ary
  :comment: |-
    Devuelve el primer elemento de +self+ y lo elimina (cambia todos
    los otros elementos por uno). Retorna <code>nil</code> si el arreglo
    está vacío.
    
    Si un número _n_ es dado, retorna un arreglo de los primeros n elementos
    (o menos) así como lo hace <code>array.slice!(0, n)</code>.
    
       args = [ "-m", "-q", "filename" ]
       args.shift     #=> "-m"
       args           #=> ["-q", "filename"]
    
       args = [ "-m", "-q", "filename" ]
       args.shift(2)  #=> ["-m", "-q"]
       args           #=> ["filename"]
- :name: unshift
  :arglist: ary.unshift(obj, ...)  -> ary
  :comment: |-
    Antepone objetos al frente de +self+,
    moviendo otros elementos hacia adelante.
    
       a = [ "b", "c", "d" ]
       a.unshift("a")   #=> ["a", "b", "c", "d"]
       a.unshift(1, 2)  #=> [ 1, 2, "a", "b", "c", "d"]
- :name: insert
  :arglist: ary.insert(index, obj...)  -> ary
  :comment: |-
    Inserta los valores dados antes del elemento con el índice dado
    (el cual podría ser negativo).
    
       a = %w{ a b c d }
       a.insert(2, 99)         #=> ["a", "b", 99, "c", "d"]
       a.insert(-2, 1, 2, 3)   #=> ["a", "b", 99, "c", 1, 2, 3, "d"]
- :name: each
  :arglist: |-
    ary.each {|item| block }   -> ary
    ary.each                   -> an_enumerator
  :comment: |-
    Llama <i>block</i> una vez por cada elemento en +self+, pasando ese
    elemento como un parámetro.
    
    Si el bloque no es dado, un enumerador es devuelto en su lugar.
    
       a = [ "a", "b", "c" ]
       a.each {|x| print x, " -- " }
    
    produce:
    
       a -- b -- c --
- :name: each_index
  :arglist: |-
    ary.each_index {|index| block }  -> ary
    ary.each_index                   -> an_enumerator
  :comment: |-
    Igual que <code>Array#each</code>, pero pasa el índice de el elemento 
    en lugar del elemento mismo.
    
    Si el bloque no es dado, un enumerador es devuelto en su lugar.
    
       a = [ "a", "b", "c" ]
       a.each_index {|x| print x, " -- " }
    
    produce:
    
       0 -- 1 -- 2 --
- :name: reverse_each
  :arglist: |-
    ary.reverse_each {|item| block }   -> ary
    ary.reverse_each                   -> an_enumerator
  :comment: |-
    Igual que <code>Array#each</code>, pero atraviesa +self+ en orden
    inverso.
    
       a = [ "a", "b", "c" ]
       a.reverse_each {|x| print x, " " }
    
    produce:
    
       c b a
- :name: length
  :arglist: ary.length -> int
  :comment: |-
    Retorna el número de elementos en +self+. Podría ser cero.
    
       [ 1, 2, 3, 4, 5 ].length   #=> 5
- :name: empty?
  :arglist: ary.empty?   -> true or false
  :comment: |-
    Retorna <code>true</code> si +self+ no contiene elementos.
    
       [].empty?   #=> true
- :name: find_index
  :arglist: |-
    ary.index(obj)           ->  int or nil
    ary.index {|item| block} ->  int or nil
    ary.index                ->  an_enumerator
  :comment: |-
    Retorna el índice el primer objeto en +self+ de tal que manera que el objeto es
    <code>==</code> a <i>obj</i>. Si un bloque es dato en lugar de un
    argumento, devuelve el índice del primer objeto cuyo <em>block</em> es verdadero.
    Retorna <code>nil</code> si no se encuentra ninguna coincidencia.
    Vea también <code>Array#rindex</code>.
    
    Si ningún bloque ni argumento es dado, un enumerador es devuelto en su lugar.
    
       a = [ "a", "b", "c" ]
       a.index("b")        #=> 1
       a.index("z")        #=> nil
       a.index{|x|x=="b"}  #=> 1
    
    Este es un alias de <code>#find_index</code>.
- :name: index
  :arglist: |-
    ary.index(obj)           ->  int or nil
    ary.index {|item| block} ->  int or nil
    ary.index                ->  an_enumerator
  :comment: |-
    Devuelve el índice el primer objeto en +self+ de tal manera que el objeto es
    <code>==</code> a <i>obj</i>. Si un bloque es dado en lugar de un
    argumento, devuelve el índice del primer objeto para el cual <em>block</em> es verdadero.
    Retorna <code>nil</code> si no se encuentran coincidencias.
    Vea también <code>Array#rindex</code>.
    
    Si ningún bloque ni argumento es dado, un enumerador es devuelto en su lugar.
    
       a = [ "a", "b", "c" ]
       a.index("b")        #=> 1
       a.index("z")        #=> nil
       a.index{|x|x=="b"}  #=> 1
    
    Este es un alias de <code>#find_index</code>.
- :name: rindex
  :arglist: |-
    ary.rindex(obj)           ->  int or nil
    ary.rindex {|item| block} ->  int or nil
    ary.rindex                ->  an_enumerator
  :comment: |-
    Retorna el índice del último objeto en +self+
    <code>==</code> a <i>obj</i>. Si un bloque es dado en lugar de un 
    argumento, devuelve el índice del primer objeto cuyo <em>block</em> es
    verdadero, comenzando desde el último objeto.
    Retorna <code>nil</code> si no se encuentran coincidencias.
    Vea también <code>Array#index</code>.
    
    Si ningún bloque ni argumento es dado, un enumerador es devuelto en su lugar.
    
       a = [ "a", "b", "b", "b", "c" ]
       a.rindex("b")        #=> 3
       a.rindex("z")        #=> nil
       a.rindex{|x|x=="b"}  #=> 3
- :name: join
  :arglist: ary.join(sep=$,)    -> str
  :comment: |-
    Retorna una cadena creada a partir de la conversión de cada elemento del arreglo a 
    una cadena, separada por <i>sep</i>.
    
       [ "a", "b", "c" ].join        #=> "abc"
       [ "a", "b", "c" ].join("-")   #=> "a-b-c"
- :name: reverse
  :arglist: ary.reverse -> new_ary
  :comment: |-
    Retorna un nuevo arreglo conteniendo los elementos de +self+ en orden inverso.
    
       [ "a", "b", "c" ].reverse   #=> ["c", "b", "a"]
       [ 1 ].reverse               #=> [1]
- :name: reverse!
  :arglist: ary.reverse!   -> ary
  :comment: |-
    Invierte +self+ en el mismo arreglo.
    
       a = [ "a", "b", "c" ]
       a.reverse!       #=> ["c", "b", "a"]
       a                #=> ["c", "b", "a"]
- :name: rotate
  :arglist: ary.rotate(cnt=1) -> new_ary
  :comment: |-
    Retorna un nuevo arreglo rotando +self+ en el que el elemento en
    +cnt+ en +self+ es el primer elemento del nuevo arreglo. Si +cnt+
    es negativo entonces se rota en la dirección opuesta.
    
       a = [ "a", "b", "c", "d" ]
       a.rotate         #=> ["b", "c", "d", "a"]
       a                #=> ["a", "b", "c", "d"]
       a.rotate(2)      #=> ["c", "d", "a", "b"]
       a.rotate(-3)     #=> ["b", "c", "d", "a"]
- :name: rotate!
  :arglist: ary.rotate!(cnt=1) -> ary
  :comment: |-
    Rota +self+ en el mismo lugar así el elemento en +cnt+ viene primero,
    y retorna +self+. Si +cnt+ es negativo entonces rota en
    la direccion opuesta.
    
       a = [ "a", "b", "c", "d" ]
       a.rotate!        #=> ["b", "c", "d", "a"]
       a                #=> ["b", "c", "d", "a"]
       a.rotate!(2)     #=> ["d", "a", "b", "c"]
       a.rotate!(-3)    #=> ["a", "b", "c", "d"]
- :name: sort
  :arglist: |-
    ary.sort                   -> new_ary
    ary.sort {| a,b | block }  -> new_ary
  :comment: |-
    Retorna un nuevo arreglo creado por el ordenamiento de +self+. Las comparaciones para
    el ordenamiento serán realizadas usando el operador <code><=></code> o usando
    un bloque de código opcional. El bloque implementa una comparación entre
    <i>a</i> y <i>b</i>, devolviendo -1, 0, ó +1. Vea también
    <code>Enumerable#sort_by</code>.
    
       a = [ "d", "a", "e", "c", "b" ]
       a.sort                    #=> ["a", "b", "c", "d", "e"]
       a.sort {|x,y| y <=> x }   #=> ["e", "d", "c", "b", "a"]
- :name: sort!
  :arglist: |-
    ary.sort!                   -> ary
    ary.sort! {| a,b | block }  -> ary
  :comment: |-
    Ordena +self+. Las comparaciones para
    el ordenamiento serán realizadas usando el operador <code><=></code> o utilizando
    un bloque de código opcional. El bloque implementa una comparación entre
    <i>a</i> y <i>b</i>, retornando -1, 0, ó +1. Vea también
    <code>Enumerable#sort_by</code>.
    
       a = [ "d", "a", "e", "c", "b" ]
       a.sort!                    #=> ["a", "b", "c", "d", "e"]
       a.sort! {|x,y| y <=> x }   #=> ["e", "d", "c", "b", "a"]
- :name: sort_by!
  :arglist: |-
    ary.sort_by! {| obj | block }    -> ary
    ary.sort_by!                     -> an_enumerator
  :comment: |-
    Ordena +self+ en el mismo arreglo utilizando un conjunto de llaves generadas por el trazado de 
    los valores en +self+ a través del bloque dado.
    
    Si ningún bloque es dado, un enumerador es devuelto en su lugar.
- :name: collect
  :arglist: |-
    ary.collect {|item| block }  -> new_ary
    ary.map     {|item| block }  -> new_ary
    ary.collect                  -> an_enumerator
    ary.map                      -> an_enumerator
  :comment: |-
    Invoca <i>block</i> una vez por cada elemento de +self+. Crea un
    nuevo arreglo conteniendo los valores devueltos por el bloque.
    Vea también <code>Enumerable#collect</code>.
    
    Si ningún bloque es dado, un enumerador es devuelto en su lugar.
    
       a = [ "a", "b", "c", "d" ]
       a.collect {|x| x + "!" }   #=> ["a!", "b!", "c!", "d!"]
       a                          #=> ["a", "b", "c", "d"]
- :name: collect!
  :arglist: |-
    ary.collect! {|item| block }   -> ary
    ary.map!     {|item| block }   -> ary
    ary.collect                    -> an_enumerator
    ary.map                        -> an_enumerator
  :comment: |-
    Invoca el bloque una vez por cada elemento de +self+, reemplazando el
    elemento con el valor retornado por _block_.
    Vea también <code>Enumerable#collect</code>.
    
    Si ningún bloque es dado, un enumerador es devuelto en su lugar.
    
       a = [ "a", "b", "c", "d" ]
       a.collect! {|x| x + "!" }
       a             #=>  [ "a!", "b!", "c!", "d!" ]
- :name: map
  :arglist: |-
    ary.collect {|item| block }  -> new_ary
    ary.map     {|item| block }  -> new_ary
    ary.collect                  -> an_enumerator
    ary.map                      -> an_enumerator
  :comment: |-
    Invoca <i>block</i> una vez por cada elemento de +self+. Crea un
    nuevo arreglo conteniendo los valores retornados por el bloque.
    Vea también <code>Enumerable#collect</code>.
    
    Si ningún bloque es dado, un enumerador es devuelto en su lugar.
    
       a = [ "a", "b", "c", "d" ]
       a.collect {|x| x + "!" }   #=> ["a!", "b!", "c!", "d!"]
       a                          #=> ["a", "b", "c", "d"]
- :name: map!
  :arglist: |-
    ary.collect! {|item| block }   -> ary
    ary.map!     {|item| block }   -> ary
    ary.collect                    -> an_enumerator
    ary.map                        -> an_enumerator
  :comment: |-
    Invoca el bloque una vez por cada elemento de +self+, reemplazando el
    elemento con el valor retornado por _block_.
    Vea también <code>Enumerable#collect</code>.
    
    Si ningún bloque es dado, un enumerador es devuelto en su lugar.
    
       a = [ "a", "b", "c", "d" ]
       a.collect! {|x| x + "!" }
       a             #=>  [ "a!", "b!", "c!", "d!" ]
- :name: select
  :arglist: |-
    ary.select {|item| block } -> new_ary
    ary.select                 -> an_enumerator
  :comment: |-
    Invoca el bloque pasando una sucesión de elementos desde +self+,
    retornando un arreglo conteniendo esos elementos para el cual el bloque
    retorna un valor verdadero (equivalente a <code>Enumerable#select</code>).
    
    Si ningún bloque es dado, un enumerador es devuelto en su lugar.
    
       a = %w{ a b c d e f }
       a.select {|v| v =~ /[aeiou]/}   #=> ["a", "e"]
- :name: select!
  :arglist: |-
    ary.select! {|item| block } -> new_ary or nil
    ary.select!                 -> an_enumerator
  :comment: |-
    Invoca el bloque pasando una sucesión de elementos desde
    +self+, elimiando los elementos para el cual el bloque retorna un
    valor falso. Retorna +self+ si los cambios fueron realizados,
    sino retorna <code>nil</code>.
    Vea también <code>Array#keep_if</code>
    
    Si ningún bloque es dado, un enumerador es devuelto en su lugar.
- :name: keep_if
  :arglist: |-
    ary.keep_if {|item| block } -> ary
    ary.keep_if                 -> an_enumerator
  :comment: |-
    Elimina cada elemento de +self+ para el que <i>block</i> evalúa
    si es falso.
    Vea también <code>Array#select!</code>
    
    Si ningún bloque es dado, un enumerador es devuelto en su lugar.
    
       a = %w{ a b c d e f }
       a.keep_if {|v| v =~ /[aeiou]/}   #=> ["a", "e"]
- :name: values_at
  :arglist: ary.values_at(selector,... )  -> new_ary
  :comment: |-
    Retorna un arreglo conteniendo los elementos en
    +self+ correspondiente al selector(es) dados. Los selectores
    podrían índices enteros o rangos.
    Vea también <code>Array#select</code>.
    
       a = %w{ a b c d e f }
       a.values_at(1, 3, 5)
       a.values_at(1, 3, 5, 7)
       a.values_at(-1, -3, -5, -7)
       a.values_at(1..3, 2...5)
- :name: delete
  :arglist: |-
    ary.delete(obj)            -> obj or nil
    ary.delete(obj) { block }  -> obj or nil
  :comment: |-
    Elimina items desde +self+ que son iguales a <i>obj</i>.
    Si no se encuentran items, retorna <i>obj</i>. Si
    el item no es encontrado, retorna <code>nil</code>. Si el bloque de código
    opcional es dado, retorna el resultado de <i>block</i> si el item
    no es encontrado. (Para remover elementos <code>nil</code> y
    obtener un valor informativo de regreso, usar #compact!)
    
       a = [ "a", "b", "b", "b", "c" ]
       a.delete("b")                   #=> "b"
       a                               #=> ["a", "c"]
       a.delete("z")                   #=> nil
       a.delete("z") { "not found" }   #=> "not found"
- :name: delete_at
  :arglist: ary.delete_at(index)  -> obj or nil
  :comment: |-
    Elimina el elemento en el índice especificado, retornando ese elemento,
    o <code>nil</code> si el índice está fuera de rango. Vea también
    <code>Array#slice!</code>.
    
       a = ["ant", "bat", "cat", "dog"]
       a.delete_at(2)    #=> "cat"
       a                 #=> ["ant", "bat", "dog"]
       a.delete_at(99)   #=> nil
- :name: delete_if
  :arglist: |-
    ary.delete_if {|item| block }  -> ary
    ary.delete_if                  -> an_enumerator
  :comment: |-
    Elimina cada elemento de +self+ por el que <i>block</i> evalúa
    si es verdadero.
    Vea también <code>Array#reject!</code>
    
    Si ningún bloque es dado, un enumerador es devuelto en su lugar.
    
       a = [ "a", "b", "c" ]
       a.delete_if {|x| x >= "b" }   #=> ["a"]
- :name: reject
  :arglist: |-
    ary.reject {|item| block }  -> new_ary
    ary.reject                  -> an_enumerator
  :comment: |-
    Retorna un nuevo arreglo conteniendo los items en +self+
    para el cual el bloque no es verdadero.
    Vea también <code>Array#delete_if</code>
    
    Si ningún bloque es dado, un enumerador es devuelto en su lugar.
- :name: reject!
  :arglist: |-
    ary.reject! {|item| block }  -> ary or nil
    ary.reject!                  -> an_enumerator
  :comment: |-
    Equivalente a <code>Array#delete_if</code>, eliminando elementos desde
    +self+ para el cual el bloque evalúa a verdadero, pero devuelve
    <code>nil</code> si ningún cambio fue realizado.
    Vea también <code>Enumerable#reject</code> y <code>Array#delete_if</code>.
    
    Si ningún bloque es dado, un enumerador es devuelto en su lugar.
- :name: zip
  :arglist: |-
    ary.zip(arg, ...)                   -> new_ary
    ary.zip(arg, ...) {| arr | block }  -> nil
  :comment: |-
    Convierte cualquier argumento en arreglos, luego une los elementos de
    +self+ con los elementos correspondientes de cada argumento. Esto
    genera una secuencia de <code>self.size</code> <em>n</em>-elementos
    de arreglos, donde <em>n</em> es uno más que el número de argumentos. Si
    el tamaño de cualquier argumento es menos que <code>enumObj.size</code>,
    el valor <code>nil</code> es suministrado. Si un bloque es dado, es
    invocado para cada salida de arreglo, sino un arreglo de arreglos es
    devuelto.
   
       a = [ 4, 5, 6 ]
       b = [ 7, 8, 9 ]
       [1,2,3].zip(a, b)      #=> [[1, 4, 7], [2, 5, 8], [3, 6, 9]]
       [1,2].zip(a,b)         #=> [[1, 4, 7], [2, 5, 8]]
       a.zip([1,2],[8])       #=> [[4,1,8], [5,2,nil], [6,nil,nil]]
- :name: transpose
  :arglist: ary.transpose -> new_ary
  :comment: |-
    Asume que +self+ es un arreglo de arreglos y transpone las
    filas y columnas.
    
       a = [[1,2], [3,4], [5,6]]
       a.transpose   #=> [[1, 3, 5], [2, 4, 6]]
- :name: replace
  :arglist: ary.replace(other_ary)  -> ary
  :comment: |-
    Reemplaza el contenido de +self+ con el contenido de
    <i>other_ary</i>, truncando o expandiendo si es necesario.
    
       a = [ "a", "b", "c", "d", "e" ]
       a.replace([ "x", "y", "z" ])   #=> ["x", "y", "z"]
       a                              #=> ["x", "y", "z"]
- :name: clear
  :arglist: ary.clear    -> ary
  :comment: |-
    Quita todos los elementos de +self+.
    
       a = [ "a", "b", "c", "d", "e" ]
       a.clear    #=> [ ]
- :name: fill
  :arglist: |-
    ary.fill(obj)                                -> ary
    ary.fill(obj, start [, length])              -> ary
    ary.fill(obj, range )                        -> ary
    ary.fill {|index| block }                    -> ary
    ary.fill(start [, length] ) {|index| block } -> ary
    ary.fill(range) {|index| block }             -> ary
  :comment: |-
    Las primeras tres formas asignan los elementos seleccionados de +self+ (la cual
    puede ser el arreglo entero) a <i>obj</i>. Un <i>start</i> de
    <code>nil</code> es equivalente a cero. Un <i>length</i> de
    <code>nil</code> es equivalente a <i>self.length</i>. Las últimas tres
    formas llenan el arreglo con el valor del bloque. El bloque
    recibe el índice absoluto de cada elemento a ser llenado.
    Los valores negativos de <i>start</i> cuenta desde el final del arreglo.
    
       a = [ "a", "b", "c", "d" ]
       a.fill("x")              #=> ["x", "x", "x", "x"]
       a.fill("z", 2, 2)        #=> ["x", "x", "z", "z"]
       a.fill("y", 0..1)        #=> ["y", "y", "z", "z"]
       a.fill {|i| i*i}         #=> [0, 1, 4, 9]
       a.fill(-2) {|i| i*i*i}   #=> [0, 1, 8, 27]
- :name: include?
  :arglist: ary.include?(obj)   -> true or false
  :comment: |-
    Devuelve <code>true</code> si el objeto dado está presente en
    +self+ (es decir, si cualquier objeto <code>==</code> <i>anObject</i>),
    si no <code>false</code>.
    
       a = [ "a", "b", "c" ]
       a.include?("b")   #=> true
       a.include?("z")   #=> false
- :name: <=>
  :arglist: ary <=> other_ary   ->  -1, 0, +1 or nil
  :comment: |-
    Comparación---Regresa un entero (-1, 0,
    o +1) si este arreglo es menor que, igual que, o mayor que 
    <i>other_ary</i>. Cada objeto en cada arreglo es comparado
    (usando <=>). Si cualquier valor no es
    igual, entonces una desigualdad es el valor devuelto. Si todos los
    valores encontrados son iguales, entonces el valor devuelto está basado sobre una
    comparación de la longitud de los arreglos. Por lo tanto, dos arreglos son
    ``iguales'' de acuerdo a <code>Array#<=></code> si y sólo si ellos tienen
    la misma longitud y el valor de cada elemento es igual al
    valor del elemento correspondiente en el otro arreglo.
    
       [ "a", "a", "c" ]    <=> [ "a", "b", "c" ]   #=> -1
       [ 1, 2, 3, 4, 5, 6 ] <=> [ 1, 2 ]            #=> +1
- :name: slice
  :arglist: |-
    ary[index]                -> obj     or nil
    ary[start, length]        -> new_ary or nil
    ary[range]                -> new_ary or nil
    ary.slice(index)          -> obj     or nil
    ary.slice(start, length)  -> new_ary or nil
    ary.slice(range)          -> new_ary or nil
  :comment: |-
    Referencia de Elemento---Devuelve el elemento en _index_,
    o devuelve un subarreglo empezando en _start_ y
    continuando por _length_ elementos, o devuelve un subarreglo
    espeficado por _range_.
    Los índices negativos cuentan en retroceso desde el final del
    arreglo (-1 es el último elemento). Devuelve +nil+ si el índice
    (o índice inicial) está fuera de rango.
    
       a = [ "a", "b", "c", "d", "e" ]
       a[2] +  a[0] + a[1]    #=> "cab"
       a[6]                   #=> nil
       a[1, 2]                #=> [ "b", "c" ]
       a[1..3]                #=> [ "b", "c", "d" ]
       a[4..7]                #=> [ "e" ]
       a[6..10]               #=> nil
       a[-3, 3]               #=> [ "c", "d", "e" ]
       # special cases
       a[5]                   #=> nil
       a[5, 1]                #=> []
       a[5..10]               #=> []
- :name: slice!
  :arglist: |-
    ary.slice!(index)         -> obj or nil
    ary.slice!(start, length) -> new_ary or nil
    ary.slice!(range)         -> new_ary or nil
  :comment: |-
    Borra el elemento(s) dado por un índice (opcionalmente con una longitud)
    o por un rango. Devuelve el objeto borrado (u objetos), o
    <code>nil</code> si el índice esta fuera de rango.
    
       a = [ "a", "b", "c" ]
       a.slice!(1)     #=> "b"
       a               #=> ["a", "c"]
       a.slice!(-1)    #=> "c"
       a               #=> ["a"]
       a.slice!(100)   #=> nil
       a               #=> ["a"]
- :name: assoc
  :arglist: ary.assoc(obj)   -> new_ary  or  nil
  :comment: |-
    Busca a través de un arreglo donde sus elementos son también arreglos
    comparando _obj_ con el primer elemento de cada arreglo contenido
    usando obj.==.
    Devuelve el primer arreglo contenido donde empareje ( es decir,
    el primer arreglo asociado),
    o +nil+ si no encuentra su igual.
    Véase también <code>Array#rassoc</code>.
    
       s1 = [ "colors", "red", "blue", "green" ]
       s2 = [ "letters", "a", "b", "c" ]
       s3 = "foo"
       a  = [ s1, s2, s3 ]
       a.assoc("letters")  #=> [ "letters", "a", "b", "c" ]
       a.assoc("foo")      #=> nil
- :name: rassoc
  :arglist: ary.rassoc(obj) -> new_ary or nil
  :comment: |-
    Busca a través del arreglo donde sus elementos son también arreglos. Compara
    _obj_ con el segundo elemento de cada arreglo contenido usando
    <code>==</code>. Devuelve el primer arreglo contenido que empareje. Véase
    también <code>Array#assoc</code>.
    
       a = [ [ 1, "one"], [2, "two"], [3, "three"], ["ii", "two"] ]
       a.rassoc("two")    #=> [2, "two"]
       a.rassoc("four")   #=> nil
- :name: +
  :arglist: ary + other_ary   -> new_ary
  :comment: |-
    Concatenación---Devuelve un nuevo arreglo construido al concatenar los
    dos arreglos juntos para producir un tercer arreglo.
    
       [ 1, 2, 3 ] + [ 4, 5 ]    #=> [ 1, 2, 3, 4, 5 ]
- :name: "*"
  :arglist: |-
    ary * int     -> new_ary
    ary * str     -> new_string
  :comment: |-
    Repetición---Con un argumento String, equivalente a
    self.join(str). Sino, devuelve un nuevo arreglo
    construido al concadenar las copias _int_ de +self+.
    
       [ 1, 2, 3 ] * 3    #=> [ 1, 2, 3, 1, 2, 3, 1, 2, 3 ]
       [ 1, 2, 3 ] * ","  #=> "1,2,3"
- :name: "-"
  :arglist: ary - other_ary    -> new_ary
  :comment: |-
    Arreglo Diferencial---Devuelve un nuevo arreglo que es una copia
    del arreglo original, removiendo cualquier artículo que aparezca también en
    <i>other_ary</i>. (Si necesita el comportamiento set-like, véase
    la librería de clases Set.)
    
       [ 1, 1, 2, 2, 3, 3, 4, 5 ] - [ 1, 2, 4 ]  #=>  [ 3, 3, 5 ]
- :name: "&"
  :arglist: ary & other_ary      -> new_ary
  :comment: |-
    Asigna Intersección---Devuelve un nuevo arreglo
    conteniendo elementos comunes a los dos arreglos, sin duplicados.
    
       [ 1, 1, 3, 5 ] & [ 1, 2, 3 ]   #=> [ 1, 3 ]
- :name: "|"
  :arglist: ary | other_ary     -> new_ary
  :comment: |-
    Asigna Unión---Devuelve un nuevo arreglo uniendo éste arreglo con
    <i>other_ary</i>, removiendo duplicados.
    
       [ "a", "b", "c" ] | [ "c", "d", "a" ]
              #=> [ "a", "b", "c", "d" ]
- :name: uniq
  :arglist: ary.uniq   -> new_ary
  :comment: |-
    Devuelve un nuevo arreglo removiendo valores duplicados en +self+.
    
       a = [ "a", "a", "b", "b", "c" ]
       a.uniq   #=> ["a", "b", "c"]
       c = [ "a:def", "a:xyz", "b:abc", "b:xyz", "c:jkl" ]
       c.uniq {|s| s[/^\w+/]}  #=> [ "a:def", "b:abc", "c:jkl" ]
- :name: uniq!
  :arglist: ary.uniq! -> ary or nil
  :comment: |-
    Remueve elementos duplicados de +self+.
    Devuelve <code>nil</code> si ningún cambio es realizado (es decir, no
    se encontró duplicados).
    
       a = [ "a", "a", "b", "b", "c" ]
       a.uniq!   #=> ["a", "b", "c"]
       b = [ "a", "b", "c" ]
       b.uniq!   #=> nil
       c = [ "a:def", "a:xyz", "b:abc", "b:xyz", "c:jkl" ]
       c.uniq! {|s| s[/^\w+/]}  #=> [ "a:def", "b:abc", "c:jkl" ]
- :name: compact
  :arglist: ary.compact     -> new_ary
  :comment: |-
    Devuelve una copia de +self+ con todos los elementos +nil+ removidos.
    
       [ "a", nil, "b", nil, "c", nil ].compact
                         #=> [ "a", "b", "c" ]
- :name: compact!
  :arglist: ary.compact!    -> ary  or  nil
  :comment: |-
    Remueve los elementos +nil+ del arreglo.
    Devuelve +nil+ si no se realizó ningún cambio, de lo contrario devuelve
    <i>ary</i>.
    
       [ "a", nil, "b", nil, "c" ].compact! #=> [ "a", "b", "c" ]
       [ "a", "b", "c" ].compact!           #=> nil
- :name: flatten
  :arglist: |-
    ary.flatten -> new_ary
    ary.flatten(level) -> new_ary
  :comment: |-
    Retorna un nuevo arreglo que es una versión unidimensional de este
    arreglo (recursivamente). Es decir, por cada elemento donde es un arreglo,
    se extrae sus elementos a un nuevo arreglo. Si el argumento de
    <i>nivel</i> opcional determina el nivel de recursión a reducir.
    
       s = [ 1, 2, 3 ]           #=> [1, 2, 3]
       t = [ 4, 5, 6, [7, 8] ]   #=> [4, 5, 6, [7, 8]]
       a = [ s, t, 9, 10 ]       #=> [[1, 2, 3], [4, 5, 6, [7, 8]], 9, 10]
       a.flatten                 #=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
       a = [ 1, 2, [3, [4, 5] ] ]
       a.flatten(1)              #=> [1, 2, 3, [4, 5]]
- :name: flatten!
  :arglist: |-
    ary.flatten!        -> ary or nil
    ary.flatten!(level) -> array or nil
  :comment: |-
    Reduce +self+ en el mismo arreglo.
    Devuelve <code>nil</code> si no se realizaron modificaciones (por ejemplo,
    <i>ary</i> no contiene subarreglos.) Si el argumento de <i>nivel</i>
    opcional determina el nivel de recusión a reducir.
    
       a = [ 1, 2, [3, [4, 5] ] ]
       a.flatten!   #=> [1, 2, 3, 4, 5]
       a.flatten!   #=> nil
       a            #=> [1, 2, 3, 4, 5]
       a = [ 1, 2, [3, [4, 5] ] ]
       a.flatten!(1) #=> [1, 2, 3, [4, 5]]
- :name: count
  :arglist: |-
    ary.count      -> int
    ary.count(obj) -> int
    ary.count { |item| block }  -> int
  :comment: |-
    Devuelve el número de elementos. Si un argumento es dado, cuenta
    el número de elementos iguales a <i>obj</i>. Si un bloque es
    dado, cuenta el número de elementos que arrojan un valor true.
    
       ary = [1, 2, 4, 2]
       ary.count             #=> 4
       ary.count(2)          #=> 2
       ary.count{|x|x%2==0}  #=> 3
- :name: shuffle!
  :arglist: |-
    ary.shuffle!              -> ary
    ary.shuffle!(random: rng) -> ary
  :comment: |-
    Mezcla los elementos en +self+ en el mismo arreglo.
    Si +rng+ es dado, será usado como el generador aleatorio de números.
- :name: shuffle
  :arglist: |-
    ary.shuffle              -> new_ary
    ary.shuffle(random: rng) -> new_ary
  :comment: |-
    Devuelve un nuevo arreglo con elementos del arreglo mezclado.
    
       a = [ 1, 2, 3 ]           #=> [1, 2, 3]
       a.shuffle                 #=> [2, 3, 1]
    
    Si +rng+ es dado, será usado como el generador aleatorio de números.
    
       a.shuffle(random: Random.new(1))  #=> [1, 3, 2]
- :name: sample
  :arglist: |-
    ary.sample                  -> obj
    ary.sample(random: rng)     -> obj
    ary.sample(n)               -> new_ary
    ary.sample(n, random: rng)  -> new_ary
  :comment: |-
    Elige un elemento aleatorio o +n+ elementos aleatorios del arreglo. Los elementos
    son escogidos usando índices aleatorios y únicos dentro del arreglo para poder asegurar
    que el elemento no se repite en sí mismo a menos que el arreglo ya contenga
    elementos duplicados. Si el arreglo está vacío la primera forma devuelve
    <code>nil</code> y la segunda forma devuelve un arreglo vacío.

    Si +rng+ es dado, será usado como el generador aleatorio de números.
- :name: cycle
  :arglist: |-
    ary.cycle(n=nil) {|obj| block }  -> nil
    ary.cycle(n=nil)                 -> an_enumerator
  :comment: |-
    Llama <i>block</i> por cada elemento repetidamente _n_ veces o
    siempre si nada o +nil+ es dado. Si un número negativo es 
    dado o el arreglo está vacío, no hace nada. Retorna +nil+ si el
    ciclo ha terminado sin ser interrumpido.

    Si ningún bloque es dado, se devuelve un enumerador.
    
       a = ["a", "b", "c"]
       a.cycle {|x| puts x }  # print, a, b, c, a, b, c,.. siempre.
       a.cycle(2) {|x| puts x }  # print, a, b, c, a, b, c.
- :name: permutation
  :arglist: |-
    ary.permutation { |p| block }          -> ary
    ary.permutation                        -> an_enumerator
    ary.permutation(n) { |p| block }       -> ary
    ary.permutation(n)                     -> an_enumerator
  :comment: |-
    Cuando es invocado con un bloque, arroja toda variante de longitud <i>n</i>
    de los elementos de <i>ary</i>, entonces devuelve el propio arreglo.
    Si <i>n</i> no está espeficado, arroja toda variante de todos los elementos.
    La implementación no garantiza el orden en la cual
    las variantes son arrojadas.

    Si ningún bloque es dado, se devuelve un enumerador.
    
    Ejemplos:
    
        a = [1, 2, 3]
        a.permutation.to_a     #=> [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
        a.permutation(1).to_a  #=> [[1],[2],[3]]
        a.permutation(2).to_a  #=> [[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]]
        a.permutation(3).to_a  #=> [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
        a.permutation(0).to_a  #=> [[]] # una variante de longitud 0
        a.permutation(4).to_a  #=> []   # sin variantes de longitud 4
- :name: combination
  :arglist: |-
    ary.combination(n) { |c| block }    -> ary
    ary.combination(n)                  -> an_enumerator
  :comment: |-
    Cuando es invocado con un bloque, produce todas las combinaciones de la longitud de <i>n</i>
    elementos desde <i>ary</i> y luego retorna el mismo <i>ary</i>.
    La implementación no garantiza el orden en el cual
    las combinaciones son producidas.
    
    Si ningún bloque es dado, un enumerador es devuelto en su lugar.
    
    Ejemplos:
    
        a = [1, 2, 3, 4]
        a.combination(1).to_a  #=> [[1],[2],[3],[4]]
        a.combination(2).to_a  #=> [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]
        a.combination(3).to_a  #=> [[1,2,3],[1,2,4],[1,3,4],[2,3,4]]
        a.combination(4).to_a  #=> [[1,2,3,4]]
        a.combination(0).to_a  #=> [[]] # una combinación de longitud 0
        a.combination(5).to_a  #=> []   # sin combinaciones de longitud 5
- :name: repeated_permutation
  :arglist: |-
    ary.repeated_permutation(n) { |p| block } -> ary
    ary.repeated_permutation(n)               -> an_enumerator
  :comment: |-
    Cuando es invocado con un bloque, arroja todas las variantes repetidas de longitud
    <i>n</i> de los elementos de <i>ary</i>, luego retorna el arreglo.
    La implementación no garantiza el orden en que
    las variantes repetidas sean arrojados.

    Si ningún bloque es dado, se retorna un enumerador.    
    Ejemplos:
    
        a = [1, 2]
        a.repeated_permutation(1).to_a  #=> [[1], [2]]
        a.repeated_permutation(2).to_a  #=> [[1,1],[1,2],[2,1],[2,2]]
        a.repeated_permutation(3).to_a  #=> [[1,1,1],[1,1,2],[1,2,1],[1,2,2],
                                        #    [2,1,1],[2,1,2],[2,2,1],[2,2,2]]
        a.repeated_permutation(0).to_a  #=> [[]] # una variante de longitud 0
- :name: repeated_combination
  :arglist: |-
    ary.repeated_combination(n) { |c| block } -> ary
    ary.repeated_combination(n)               -> an_enumerator
  :comment: |-
    Cuando es invocado con un bloque, arroja todas las combinaciones repetidas de
    longitud <i>n</i> de los elementos de <i>ary</i> y luego retorna
    al mismo <i>ary</i>.
    La implementación no garantiza el orden en que
    las variantes repetidas sean arrojados.
    
    Si ningún bloque es dado, se retorna un enumerador.  
    Ejemplos:
    
        a = [1, 2, 3]
        a.repeated_combination(1).to_a  #=> [[1], [2], [3]]
        a.repeated_combination(2).to_a  #=> [[1,1],[1,2],[1,3],[2,2],[2,3],[3,3]]
        a.repeated_combination(3).to_a  #=> [[1,1,1],[1,1,2],[1,1,3],[1,2,2],[1,2,3],
                                        #    [1,3,3],[2,2,2],[2,2,3],[2,3,3],[3,3,3]]
        a.repeated_combination(4).to_a  #=> [[1,1,1,1],[1,1,1,2],[1,1,1,3],[1,1,2,2],[1,1,2,3],
                                        #    [1,1,3,3],[1,2,2,2],[1,2,2,3],[1,2,3,3],[1,3,3,3],
                                        #    [2,2,2,2],[2,2,2,3],[2,2,3,3],[2,3,3,3],[3,3,3,3]]
        a.repeated_combination(0).to_a  #=> [[]] # una combinación de longitud 0
- :name: product
  :arglist: |-
    ary.product(other_ary, ...)                -> new_ary
    ary.product(other_ary, ...) { |p| block }  -> ary
  :comment: |-
    Retorna un arreglo de todas las combinaciones de elementos de todos los arreglos,
    La longitud del arreglo retornado es el producto de la longitud
    de +self+ por los arreglos de argumento.
    Si un bloque es dado, el <i>producto</i> arrojará todas las combinaciones
    y en su lugar retorna +self+.
    
       [1,2,3].product([4,5])     #=> [[1,4],[1,5],[2,4],[2,5],[3,4],[3,5]]
       [1,2].product([1,2])       #=> [[1,1],[1,2],[2,1],[2,2]]
       [1,2].product([3,4],[5,6]) #=> [[1,3,5],[1,3,6],[1,4,5],[1,4,6],
                                  #     [2,3,5],[2,3,6],[2,4,5],[2,4,6]]
       [1,2].product()            #=> [[1],[2]]
       [1,2].product([])          #=> []
- :name: take
  :arglist: ary.take(n)               -> new_ary
  :comment: |-
    Retorna los primeros n elementos de <i>ary</i>.
    
       a = [1, 2, 3, 4, 5, 0]
       a.take(3)             #=> [1, 2, 3]
- :name: take_while
  :arglist: |-
    ary.take_while {|arr| block }   -> new_ary
    ary.take_while                  -> an_enumerator
  :comment: |-
    Pasa elementos al bloque hasta que el bloque retorne +nil+ o +false+,
    luego deja de iterar y retorna un arreglo de todos los elementos previos.

    Si ningún bloque es dado, se devuelve un enumerador en su lugar.
    
       a = [1, 2, 3, 4, 5, 0]
       a.take_while {|i| i < 3 }   #=> [1, 2]
- :name: drop
  :arglist: ary.drop(n)               -> new_ary
  :comment: |-
    Bota los primeros n elementos de +ary+ y retorna el resto de
    los elementos en un arreglo.
    
       a = [1, 2, 3, 4, 5, 0]
       a.drop(3)             #=> [4, 5, 0]
- :name: drop_while
  :arglist: |-
    ary.drop_while {|arr| block }   -> new_ary
    ary.drop_while                  -> an_enumerator
  :comment: |-
    Bota los elementos hasta, pero sin incluir, el primer elemento para
    la cual el bloque retorne +self+ o +false+ y retorna un arreglo
    conteniendo los elementos restante.

    Si ningún bloque es dado, se retorna un enumerador en su lugar.
    
       a = [1, 2, 3, 4, 5, 0]
       a.drop_while {|i| i < 3 }   #=> [3, 4, 5, 0]
- :name: to_s
  :arglist: to_s()
  :comment: ""
- :name: size
  :arglist: size()
  :comment: ""
- :name: pack
  :arglist: arr.pack ( aTemplateString ) -> aBinaryString
  :comment: |-
    Empaqueta el contenido de <i>arr</i> en una secuencia binaria de acuerdo a
    las directivas en <i>aTemplateString</i> (vea la tabla debajo)
    Directivas ``A,'' ``a,'' y ``Z'' pueden estar seguidas por una cuenta,
    la cual da el ancho del campo resultante. Las directivas restantes
    también pueden tomar una cuenta, indicando el número de elementos 
    arreglo a convertir. Si la cuenta es un asterisco
    (``<code>*</code>''), todos los elementos arreglo restantes serán
    convertidos. Cualquier directorio  ``<code>sSiIlL</code>'' puede ser
    seguido de un underscore (``<code>_</code>'') o
    un signo de exclamación (``<code>!</code>'') para usar el tamaño nativo
    de la plataforma subyacente para el tipo especificado; de otra forma, usarán
    un tamaño independiente de la plataforma. Los espacios son ignorados en la plantilla
    String. Veáse también <code>String#unpack</code>.
    
       a = [ "a", "b", "c" ]
       n = [ 65, 66, 67 ]
       a.pack("A3A3A3")   #=> "a  b  c  "
       a.pack("a3a3a3")   #=> "a\000\000b\000\000c\000\000"
       n.pack("ccc")      #=> "ABC"
    
    Directivas para +pack+.
    
     Entero       | Arreglo  |
     Directiva    | Elemento | Significado
     ---------------------------------------------------------------------------
        C         | Entero   | 8-bit sin signo (caracter sin signo)
        S         | Entero   | 16-bit sin signo, endianicidad nativa (uint16_t)
        L         | Entero   | 32-bit sin signo, endianicidad nativa (uint32_t)
        Q         | Entero   | 64-bit sin signo, endianicidad nativa (uint64_t)
                  |          |
        c         | Entero   | 8-bit signed (signed char)
        s         | Entero   | 16-bit signed, endianicidad nativa (int16_t)
        l         | Entero   | 32-bit signed, endianicidad nativa (int32_t)
        q         | Entero   | 64-bit signed, endianicidad nativa (int64_t)
                  |          |
        S_, S!    | Entero   | sin signo short, endianicidad nativa
        I, I_, I! | Entero   | sin signo int, endianicidad nativa
        L_, L!    | Entero   | sin signo long, endianicidad nativa
                  |          |
        s_, s!    | Entero   | signed short, endianicidad nativa
        i, i_, i! | Entero   | signed int, endianicidad nativa
        l_, l!    | Entero   | signed long, endianicidad nativa
                  |          |
        S> L> Q>  | Entero   | igual como las directivas sin ">" excepto
        s> l> q>  |          | big endian
        S!> I!>   |          | (available since Ruby 1.9.3)
        L!>       |          | "S>" is same as "n"
        s!> i!>   |          | "L>" is same as "N"
        l!>       |          |
                  |          |
        S< L< Q<  | Entero   | igual como las directivas sin "<" excepto
        s< l< q<  |          | little endian
        S!< I!<   |          | (disponible desde Ruby 1.9.3)
        L!<       |          | "S<" is same as "v"
        s!< i!<   |          | "L<" is same as "V"
        l!<       |          |
                  |          |
        n         | Entero   | 16-bit sin signo, red (big-endian) orden de byte 
        N         | Entero   | 32-bit sin signo, red (big-endian) orden de byte
        v         | Entero   | 16-bit sin signo, VAX (little-endian) orden de byte
        V         | Entero   | 32-bit sin signo, VAX (little-endian) orden de byte
                  |          |
        U         | Entero   | UTF-8 caracter
        w         | Entero   | BER-comprimido entero
    
     Float        |          |
     Directiva    |          | Significado
     ---------------------------------------------------------------------------
        D, d      | Flotante | double-precision, formato nativo
        F, f      | Flotante | single-precision, formato nativo
        E         | Flotante | double-precision, little-endian orden de byte
        e         | Flotante | single-precision, little-endian orden de byte
        G         | Flotante | double-precision, network (big-endian) orden de byte
        g         | Flotante | single-precision, network (big-endian) orden de byte
    
     String       |          |
     Directiva    |          | Significado
     ---------------------------------------------------------------------------
        A         | Cadena   | binario arbitrario string (espacio de relleno, contador es el ancho)
        a         | Cadena   | binario arbitrario string (null relleno, contador es el ancho)
        Z         | Cadena   | igual como ``a'', excepto que null es añadido con *
        B         | Cadena   | bit string (MSB primero)
        b         | Cadena   | bit string (LSB primero)
        H         | Cadena   | hex string (cuado alto primero)
        h         | Cadena   | hex string (cuado bajo primero)
        u         | Cadena   | UU-encoded string
        M         | Cadena   | cita imprimible, codificación MIME (vea RFC2045)
        m         | Cadena   | codificación string base64 (vea RFC 2045, contador es el ancho)
                  |          | (si el contador es 0, ninguna línea es agregada, vea RFC 4648)
        P         | Cadena   | puntero a estructura (string de longitud arreglada)
        p         | Cadena   | puntero a string terminado en null
    
     Misc.        |          |
     Directiva    |          | Significado
     ---------------------------------------------------------------------------
        @         | ---      | se mueve a una posición absoluta
        X         | ---      | respalda un byte
        x         | ---      | null byte
:class_methods: 
- :name: "[]"
  :arglist: "[](*args)"
  :comment: |-
    Devuelve un nuevo arreglo poblado con los objetos dados.
    
      Array.[]( 1, 'a', /^A/ )
      Array[ 1, 'a', /^A/ ]
      [ 1, 'a', /^A/ ]
- :name: try_convert
  :arglist: Array.try_convert(obj) -> array or nil
  :comment: |-
    Intenta convertir <i>obj</i> en un arreglo, usando el método +to_ary+.
    Devuelve arreglos convertidos o +nil+ si <i>obj</i> no puede ser convertido
    por alguna razón. Éste método puede ser usado para revisar si un argumento es un
    arreglo.
    
       Array.try_convert([1])   #=> [1]
       Array.try_convert("1")   #=> nil
    
       if tmp = Array.try_convert(arg)
         # el argumento es un arreglo
       elsif tmp = String.try_convert(arg)
         # el argumento es una cadena
       end
- :name: new
  :arglist: |-
    Array.new(size=0, obj=nil)
    Array.new(array)
    Array.new(size) {|index| block }
  :comment: |-
    Regresa un nuevo arreglo. En la primera forma, el nuevo arreglo esta
    vacío. En la segunda es creada con las copias _size_ de _obj_
    (es decir, _size_ se referencia al mismo
    _obj_). La tercera forma crea una copia del arreglo
    pasado como un parámetro (el arreglo es generado al llamar
    to_ary en el parámetro). En la última forma, un arreglo
    del tamaño dado es creado. Cada elemento en este arreglo es
    calculado pasando el índice del elemento al bloque dado
    y almacenando el valor devuelto.
    
       Array.new
       Array.new(2)
       Array.new(5, "A")
    
       # solo una copia del objeto es creado
       a = Array.new(2, Hash.new)
       a[0]['cat'] = 'feline'
       a
       a[1]['cat'] = 'Felix'
       a
    
       # aquí múltiples copias son creados
       a = Array.new(2) { Hash.new }
       a[0]['cat'] = 'feline'
       a
    
       squares = Array.new(5) {|i| i*i}
       squares
    
       copy = Array.new(squares)
